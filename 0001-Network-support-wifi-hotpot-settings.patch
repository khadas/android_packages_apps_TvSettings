From 68e70c8c557fe4b964e16f02f08ad6d1ba6fb7e7 Mon Sep 17 00:00:00 2001
From: jason <jason@khadas.com>
Date: Thu, 14 Apr 2022 03:16:31 +0000
Subject: [PATCH] Network: support wifi hotpot settings

Signed-off-by: jason <jason@khadas.com>
Change-Id: I3f13995cf8d4b3ef4e7448ae4a008ed9ea3c193a
---
 Settings/AndroidManifest.xml                  |  33 +
 .../res/drawable/ic_launcher_settings.png     | Bin 0 -> 8605 bytes
 Settings/res/layout/content_vpn_create.xml    | 280 +++++++
 .../res/layout/preference_widget_settings.xml |  19 +
 Settings/res/layout/wifi_ap_dialog_my.xml     | 180 +++++
 Settings/res/values-zh-rCN/strings.xml        |  75 ++
 Settings/res/values/arrays.xml                |  47 ++
 Settings/res/values/strings.xml               | 151 ++++
 Settings/res/values/styles.xml                |  47 ++
 Settings/res/xml/hotpot.xml                   |  33 +
 Settings/res/xml/network.xml                  |  29 +-
 .../connectivity/DialogCreatable.java         |  29 +
 .../settings/connectivity/HotPotActivity.java |  27 +
 .../settings/connectivity/HotPotFragment.java | 751 ++++++++++++++++++
 .../connectivity/HotpotDialogActivity.java    | 397 +++++++++
 .../connectivity/NetworkFragment.java         | 227 +++++-
 .../settings/connectivity/WifiApDialog.java   | 278 +++++++
 .../settings/connectivity/WifiApEnabler.java  | 180 +++++
 .../tv/settings/vpn/GearPreference.java       |  65 ++
 .../tv/settings/vpn/LegacyVpnPreference.java  |  71 ++
 .../tv/settings/vpn/ManageablePreference.java |  95 +++
 .../tv/settings/vpn/VpnCreateActivity.java    | 615 ++++++++++++++
 .../com/android/tv/settings/vpn/VpnUtils.java |  51 ++
 23 files changed, 3677 insertions(+), 3 deletions(-)
 create mode 100755 Settings/res/drawable/ic_launcher_settings.png
 create mode 100755 Settings/res/layout/content_vpn_create.xml
 create mode 100755 Settings/res/layout/preference_widget_settings.xml
 create mode 100755 Settings/res/layout/wifi_ap_dialog_my.xml
 create mode 100755 Settings/res/xml/hotpot.xml
 create mode 100755 Settings/src/com/android/tv/settings/connectivity/DialogCreatable.java
 create mode 100755 Settings/src/com/android/tv/settings/connectivity/HotPotActivity.java
 create mode 100755 Settings/src/com/android/tv/settings/connectivity/HotPotFragment.java
 create mode 100755 Settings/src/com/android/tv/settings/connectivity/HotpotDialogActivity.java
 create mode 100755 Settings/src/com/android/tv/settings/connectivity/WifiApDialog.java
 create mode 100755 Settings/src/com/android/tv/settings/connectivity/WifiApEnabler.java
 create mode 100755 Settings/src/com/android/tv/settings/vpn/GearPreference.java
 create mode 100755 Settings/src/com/android/tv/settings/vpn/LegacyVpnPreference.java
 create mode 100755 Settings/src/com/android/tv/settings/vpn/ManageablePreference.java
 create mode 100755 Settings/src/com/android/tv/settings/vpn/VpnCreateActivity.java
 create mode 100755 Settings/src/com/android/tv/settings/vpn/VpnUtils.java

diff --git a/Settings/AndroidManifest.xml b/Settings/AndroidManifest.xml
index 5ca2e626..fbce945a 100755
--- a/Settings/AndroidManifest.xml
+++ b/Settings/AndroidManifest.xml
@@ -848,6 +848,39 @@
                 <action android:name="com.android.settings.action.SUGGESTION_STATE_PROVIDER" />
             </intent-filter>
         </provider>
+        <activity
+            android:name="MainSettings$ScanningSettingsActivity">
+            <intent-filter android:priority="1">
+                <action android:name="android.settings.LOCATION_SCANNING_SETTINGS" />
+                <category android:name="android.intent.category.DEFAULT" />
+            </intent-filter>
+            <meta-data android:name="com.android.settings.FRAGMENT_CLASS"
+                android:value="com.android.settings.location.ScanningSettings" />
+            <meta-data android:name="com.android.settings.PRIMARY_PROFILE_CONTROLLED"
+                android:value="true" />
+        </activity>
+
+        <activity
+              android:name="com.android.tv.settings.vpn.VpnCreateActivity"
+              android:configChanges="keyboard"
+              android:windowSoftInputMode="adjustPan">
+              <intent-filter>
+                <category android:name="android.intent.category.DEFAULT" />
+              </intent-filter>
+         </activity>
+
+        <activity
+            android:name=".connectivity.HotPotActivity" >
+        </activity>
+        <activity
+            android:name=".connectivity.WifiApDialog" >
+        </activity>
+        <activity
+            android:name=".connectivity.HotpotDialogActivity">
+            <intent-filter>
+                <category android:name="android.intent.category.DEFAULT" />
+            </intent-filter>
+        </activity>
     </application>
 
 </manifest>
diff --git a/Settings/res/drawable/ic_launcher_settings.png b/Settings/res/drawable/ic_launcher_settings.png
new file mode 100755
index 0000000000000000000000000000000000000000..fa8c81357547c6e93f26b1880f9841350b1c542a
GIT binary patch
literal 8605
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

literal 0
HcmV?d00001

diff --git a/Settings/res/layout/content_vpn_create.xml b/Settings/res/layout/content_vpn_create.xml
new file mode 100755
index 00000000..51fb8b13
--- /dev/null
+++ b/Settings/res/layout/content_vpn_create.xml
@@ -0,0 +1,280 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+     Copyright (C) 2011 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="wrap_content"
+    android:orientation="vertical"
+    android:padding="8dp" >
+
+    <LinearLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:gravity="right"
+        android:orientation="horizontal"
+        android:weightSum="2" >
+
+        <Button
+            android:id="@+id/btn_edit"
+            android:layout_width="0dp"
+            android:layout_height="wrap_content"
+            android:layout_weight="1"
+            android:padding="10dp"
+            android:text="@string/edit"
+            android:visibility="gone" />
+    </LinearLayout>
+
+    <LinearLayout
+        android:id="@+id/editor"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:orientation="vertical"
+        android:visibility="gone" >
+
+        <TextView
+            style="@style/vpn_label"
+            android:text="@string/vpn_name" />
+
+        <EditText
+            android:id="@+id/name"
+            style="@style/vpn_value"
+            android:inputType="textCapWords" />
+
+        <TextView
+            style="@style/vpn_label"
+            android:text="@string/vpn_type" />
+
+        <Spinner
+            android:id="@+id/type"
+            style="@style/vpn_value"
+            android:entries="@array/vpn_types"
+            android:prompt="@string/vpn_type" />
+
+        <TextView
+            style="@style/vpn_label"
+            android:text="@string/vpn_server" />
+
+        <EditText
+            android:id="@+id/server"
+            style="@style/vpn_value" />
+
+        <CheckBox
+            android:id="@+id/mppe"
+            style="@style/vpn_value"
+            android:singleLine="false"
+            android:text="@string/vpn_mppe"
+            android:visibility="gone" />
+
+        <LinearLayout
+            android:id="@+id/l2tp"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:orientation="vertical"
+            android:visibility="gone" >
+
+            <TextView
+                style="@style/vpn_label"
+                android:text="@string/vpn_l2tp_secret" />
+
+            <EditText
+                android:id="@+id/l2tp_secret"
+                style="@style/vpn_value"
+                android:hint="@string/vpn_not_used"
+                android:password="true" />
+        </LinearLayout>
+
+        <LinearLayout
+            android:id="@+id/ipsec_psk"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:orientation="vertical"
+            android:visibility="gone" >
+
+            <TextView
+                style="@style/vpn_label"
+                android:text="@string/vpn_ipsec_identifier" />
+
+            <EditText
+                android:id="@+id/ipsec_identifier"
+                style="@style/vpn_value"
+                android:hint="@string/vpn_not_used" />
+
+            <TextView
+                style="@style/vpn_label"
+                android:text="@string/vpn_ipsec_secret" />
+
+            <EditText
+                android:id="@+id/ipsec_secret"
+                style="@style/vpn_value"
+                android:password="true" />
+        </LinearLayout>
+
+        <LinearLayout
+            android:id="@+id/ipsec_user"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:orientation="vertical"
+            android:visibility="gone" >
+
+            <TextView
+                style="@style/vpn_label"
+                android:text="@string/vpn_ipsec_user_cert" />
+
+            <Spinner
+                android:id="@+id/ipsec_user_cert"
+                style="@style/vpn_value"
+                android:prompt="@string/vpn_ipsec_user_cert" />
+        </LinearLayout>
+
+        <LinearLayout
+            android:id="@+id/ipsec_peer"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:orientation="vertical"
+            android:visibility="gone" >
+
+            <TextView
+                style="@style/vpn_label"
+                android:text="@string/vpn_ipsec_ca_cert" />
+
+            <Spinner
+                android:id="@+id/ipsec_ca_cert"
+                style="@style/vpn_value"
+                android:prompt="@string/vpn_ipsec_ca_cert" />
+
+            <TextView
+                style="@style/vpn_label"
+                android:text="@string/vpn_ipsec_server_cert" />
+
+            <Spinner
+                android:id="@+id/ipsec_server_cert"
+                style="@style/vpn_value"
+                android:prompt="@string/vpn_ipsec_server_cert" />
+        </LinearLayout>
+
+        <CheckBox
+            android:id="@+id/show_options"
+            style="@style/vpn_value"
+            android:singleLine="false"
+            android:text="@string/vpn_show_options" />
+    </LinearLayout>
+
+    <LinearLayout
+        android:id="@+id/options"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:orientation="vertical"
+        android:visibility="gone" >
+
+        <TextView
+            style="@style/vpn_label"
+            android:text="@string/vpn_search_domains" />
+
+        <EditText
+            android:id="@+id/search_domains"
+            style="@style/vpn_value"
+            android:hint="@string/vpn_not_used" />
+
+        <TextView
+            style="@style/vpn_label"
+            android:text="@string/vpn_dns_servers" />
+
+        <EditText
+            android:id="@+id/dns_servers"
+            style="@style/vpn_value"
+            android:hint="@string/vpn_not_used" />
+
+        <TextView
+            style="@style/vpn_label"
+            android:text="@string/vpn_routes" />
+
+        <EditText
+            android:id="@+id/routes"
+            style="@style/vpn_value"
+            android:hint="@string/vpn_not_used" />
+    </LinearLayout>
+
+    <LinearLayout
+        android:id="@+id/login"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:orientation="vertical" >
+
+        <TextView
+            style="@style/vpn_label"
+            android:text="@string/vpn_username" />
+
+        <EditText
+            android:id="@+id/username"
+            style="@style/vpn_value" />
+
+        <TextView
+            style="@style/vpn_label"
+            android:text="@string/vpn_password" />
+
+        <EditText
+            android:id="@+id/password"
+            style="@style/vpn_value"
+            android:password="true" />
+
+        <CheckBox
+            android:id="@+id/save_login"
+            style="@style/vpn_value"
+            android:singleLine="false"
+            android:text="@string/vpn_save_login" />
+
+        <CheckBox
+            android:id="@+id/always_on_vpn"
+            style="@style/vpn_value"
+            android:singleLine="false"
+            android:text="@string/vpn_menu_lockdown" />
+    </LinearLayout>
+
+    <LinearLayout
+        android:id="@+id/layout_control"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:orientation="horizontal" >
+
+        <Button
+            android:id="@+id/btn_forget"
+            android:layout_width="0dp"
+            android:layout_height="wrap_content"
+            android:layout_weight="1"
+            android:padding="10dp"
+            android:text="@string/vpn_forget"
+            android:visibility="gone" />
+
+        <Button
+            android:id="@+id/btn_ok"
+            android:layout_width="0dp"
+            android:layout_height="wrap_content"
+            android:layout_weight="1"
+            android:padding="10dp"
+            android:text="@string/ok" />
+
+        <Button
+            android:id="@+id/btn_cancel"
+            android:layout_width="0dp"
+            android:layout_height="wrap_content"
+            android:layout_marginLeft="20dp"
+            android:layout_weight="1"
+            android:padding="10dp"
+            android:text="@string/cancel" />
+    </LinearLayout>
+
+</LinearLayout>
\ No newline at end of file
diff --git a/Settings/res/layout/preference_widget_settings.xml b/Settings/res/layout/preference_widget_settings.xml
new file mode 100755
index 00000000..79df9a84
--- /dev/null
+++ b/Settings/res/layout/preference_widget_settings.xml
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="wrap_content"
+    android:layout_height="wrap_content"
+    android:gravity="center_vertical"
+    android:paddingEnd="?android:attr/scrollbarSize" >
+
+    <!-- Settings button -->
+
+    <ImageView
+        android:id="@+id/settings_button"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_gravity="center_vertical"
+        android:background="?android:attr/selectableItemBackground"
+        android:padding="8dip"
+        android:src="@drawable/ic_settings" />
+
+</LinearLayout>
\ No newline at end of file
diff --git a/Settings/res/layout/wifi_ap_dialog_my.xml b/Settings/res/layout/wifi_ap_dialog_my.xml
new file mode 100755
index 00000000..775b69de
--- /dev/null
+++ b/Settings/res/layout/wifi_ap_dialog_my.xml
@@ -0,0 +1,180 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2010 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
+         android:layout_width="300sp"
+         android:layout_height="wrap_content"
+         android:fadeScrollbars="false">
+
+    <LinearLayout
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:descendantFocusability="beforeDescendants"
+            android:focusableInTouchMode="true"
+            android:orientation="vertical">
+
+        <LinearLayout android:id="@+id/info"
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                style="@style/wifi_section" />
+
+        <LinearLayout android:id="@+id/type"
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                style="@style/wifi_section"
+                android:visibility="visible">
+
+            <LinearLayout
+                    android:layout_width="match_parent"
+                    android:layout_height="wrap_content"
+                    style="@style/wifi_item">
+                <TextView
+                        android:layout_width="match_parent"
+                        android:layout_height="wrap_content"
+                        style="@style/wifi_item_label"
+                        android:layout_marginTop="8dip"
+                        android:text="@string/wifi_ssid" />
+
+                <EditText android:id="@+id/ssid"
+                        android:layout_width="match_parent"
+                        android:layout_height="wrap_content"
+                        style="@style/wifi_item_edit_content"
+                        android:singleLine="true"
+                        android:hint="@string/wifi_ssid_hint"
+                        android:inputType="textNoSuggestions"
+                        android:maxLength="32" />
+            </LinearLayout>
+
+            <LinearLayout
+                    android:layout_width="match_parent"
+                    android:layout_height="wrap_content"
+                    style="@style/wifi_item">
+                <TextView
+                        android:layout_width="match_parent"
+                        android:layout_height="wrap_content"
+                        style="@style/wifi_item_label"
+                        android:layout_marginTop="8dip"
+                        android:text="@string/wifi_security" />
+
+                <Spinner android:id="@+id/security"
+                        android:layout_width="match_parent"
+                        android:layout_height="wrap_content"
+                        style="@style/wifi_item_content"
+                        android:prompt="@string/wifi_security"
+                        android:entries="@array/wifi_ap_security" />
+            </LinearLayout>
+
+        </LinearLayout>
+
+        <LinearLayout android:id="@+id/fields"
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                style="@style/wifi_section"
+                android:visibility="visible">
+
+            <LinearLayout
+                    android:layout_width="match_parent"
+                    android:layout_height="wrap_content"
+                    style="@style/wifi_item">
+                <TextView
+                        android:layout_width="match_parent"
+                        android:layout_height="wrap_content"
+                        style="@style/wifi_item_label"
+                        android:layout_marginTop="8dip"
+                        android:text="@string/wifi_password" />
+
+                <EditText android:id="@+id/password"
+                        android:layout_width="match_parent"
+                        android:layout_height="wrap_content"
+                        style="@style/wifi_item_edit_content"
+                        android:singleLine="true"
+                        android:password="true"
+                        android:maxLength="63"
+                        android:imeOptions="flagForceAscii" />
+            </LinearLayout>
+
+            <LinearLayout
+                    android:layout_width="match_parent"
+                    android:layout_height="wrap_content"
+                    style="@style/wifi_item">
+                <TextView android:id="@+id/hint"
+                        android:layout_width="match_parent"
+                        android:layout_height="wrap_content"
+                        style="@style/wifi_item_label"
+                        android:text="@string/credentials_password_too_short"
+                        android:layout_marginTop="8dip"
+                        android:layout_marginBottom="10sp"/>
+
+                <CheckBox android:id="@+id/show_password"
+                        android:layout_width="match_parent"
+                        android:layout_height="wrap_content"
+                        style="@style/wifi_item_content"
+                        android:text="@string/wifi_show_password" />
+            </LinearLayout>
+        </LinearLayout>
+
+        <LinearLayout android:id="@+id/fields"
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                style="@style/wifi_section" >
+
+            <LinearLayout
+                    android:layout_width="match_parent"
+                    android:layout_height="wrap_content"
+                    style="@style/wifi_item">
+                <TextView
+                    android:layout_width="match_parent"
+                    android:layout_height="wrap_content"
+                    style="@style/wifi_item_label"
+                    android:layout_marginTop="8dip"
+                    android:text="@string/wifi_ap_band_config" />
+
+                <Spinner android:id="@+id/choose_channel"
+                    android:layout_width="match_parent"
+                    android:layout_height="wrap_content"
+                    style="@style/wifi_item_content"
+                    android:prompt="@string/wifi_ap_band_config"
+					android:entries="@array/wifi_ap_band_config_full"
+					/>
+            </LinearLayout>
+        </LinearLayout>
+
+		<LinearLayout
+			android:layout_width="match_parent"
+			android:layout_height="wrap_content"
+			android:orientation="horizontal"
+			android:gravity="right">
+
+        <Button
+            android:id="@+id/NO"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:text="@string/no_button"
+            />
+
+        <Button
+            android:id="@+id/OK"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+			android:text="@string/ok_button"
+            />
+
+    </LinearLayout>
+
+    </LinearLayout>
+
+
+</ScrollView>
diff --git a/Settings/res/values-zh-rCN/strings.xml b/Settings/res/values-zh-rCN/strings.xml
index 0d23fa66..5249a410 100755
--- a/Settings/res/values-zh-rCN/strings.xml
+++ b/Settings/res/values-zh-rCN/strings.xml
@@ -900,4 +900,79 @@
     <string name="yes">"是"</string>
     <!-- Strings for Dialog no button -->
     <string name="no">"否"</string>
+    <!-- VPN interface -->
+    <string name="create_vpn" >创建VPN</string>
+     <string name="vpn_name" msgid="4689699885361002297">"名称"</string>
+    <string name="vpn_type" msgid="5435733139514388070">"类型"</string>
+    <string name="vpn_server" msgid="2123096727287421913">"服务器地址"</string>
+    <string name="vpn_mppe" msgid="6639001940500288972">"PPP加密(MPPE)"</string>
+    <string name="vpn_l2tp_secret" msgid="529359749677142076">"L2TP 密钥"</string>
+    <string name="vpn_ipsec_identifier" msgid="4098175859460006296">"IPSec 标识符"</string>
+    <string name="vpn_ipsec_secret" msgid="4526453255704888704">"IPSec 预共享密钥"</string>
+    <string name="vpn_ipsec_user_cert" msgid="6880651510020187230">"IPSec 用户证书"</string>
+    <string name="vpn_ipsec_ca_cert" msgid="91338213449148229">"IPSec CA证书"</string>
+    <string name="vpn_ipsec_server_cert" msgid="6599276718456935010">"IPSec 服务器证书"</string>
+    <string name="vpn_show_options" msgid="7182688955890457003">"显示高级选项"</string>
+    <string name="vpn_search_domains" msgid="5391995501541199624">"DNS搜索网域"</string>
+    <string name="vpn_dns_servers" msgid="5570715561245741829">"DNS服务器（例如8.8.8.8）"</string>
+    <string name="vpn_routes" msgid="3818655448226312232">"转发路线（例如10.0.0.0/8）"</string>
+    <string name="vpn_username" msgid="1863901629860867849">"用户名"</string>
+    <string name="vpn_password" msgid="6756043647233596772">"密码"</string>
+    <string name="vpn_save_login" msgid="6350322456427484881">"保存帐号信息"</string>
+    <string name="vpn_not_used" msgid="9094191054524660891">"（未使用）"</string>
+    <string name="vpn_no_ca_cert" msgid="8776029412793353361">"（不验证服务器）"</string>
+    <string name="vpn_no_server_cert" msgid="2167487440231913330">"（来自服务器）"</string>
+    <string name="vpn_cancel" msgid="1979937976123659332">"取消"</string>
+    <string name="vpn_done" msgid="8678655203910995914">"关闭"</string>
+    <string name="vpn_save" msgid="4233484051644764510">"保存"</string>
+    <string name="vpn_connect" msgid="8469608541746132301">"连接"</string>
+    <string name="vpn_replace" msgid="5442836256121957861">"替换"</string>
+    <string name="vpn_edit" msgid="8647191407179996943">"编辑VPN配置文件"</string>
+    <string name="vpn_forget" msgid="3684651372749415446">"取消保存"</string>
+    <string name="vpn_connect_to" msgid="5965299358485793260">"连接到<xliff:g id="PROFILE">%s</xliff:g>"</string>
+    <string name="vpn_disconnect_confirm" msgid="2555877026824771115">"断开此 VPN 连接。"</string>
+    <string name="vpn_disconnect" msgid="7426570492642111171">"断开连接"</string>
+    <string name="vpn_version" msgid="1939804054179766249">"版本 <xliff:g id="VERSION">%s</xliff:g>"</string>
+    <string name="vpn_forget_long" msgid="2232239391189465752">"取消保存 VPN"</string>
+    <string name="vpn_replace_always_on_vpn_title" msgid="3010435028275752220">"替换现有 VPN？"</string>
+    <string name="vpn_replace_always_on_vpn_message" msgid="4764679857158814028">"您已连接到 VPN。如果要连接到其他 VPN，则系统将替换现有 VPN。"</string>
+    <string name="vpn_cant_connect_title" msgid="4517706987875907511">"无法连接到<xliff:g id="VPN_NAME">%1$s</xliff:g>"</string>
+    <string name="vpn_cant_connect_message" msgid="2593197919352621279">"此应用不支持始终开启的 VPN。"</string>
+    <string name="vpn_title" msgid="6317731879966640551">"VPN"</string>
+    <string name="vpn_create" msgid="5628219087569761496">"添加VPN配置文件"</string>
+    <string name="vpn_menu_edit" msgid="408275284159243490">"修改配置文件"</string>
+    <string name="vpn_menu_delete" msgid="8098021690546891414">"删除配置文件"</string>
+    <string name="vpn_menu_lockdown" msgid="7863024538064268139">"始终开启的 VPN"</string>
+    <string name="vpn_no_vpns_added" msgid="4308317205962153438">"尚未添加任何 VPN。"</string>
+    <string name="vpn_always_on_active" msgid="2789423425184556882">"始终处于开启状态"</string>
+    <string name="vpn_not_supported_by_this_app" msgid="5002053874215892179">"此应用不支持这项功能"</string>
+    <string name="vpn_lockdown_summary" msgid="2200032066376720339">"选择要始终保持连接的VPN配置文件。只有在连接到此VPN之后才可以使用网络。"</string>
+    <string name="vpn_lockdown_none" msgid="9214462857336483711">"无"</string>
+    <string name="vpn_lockdown_config_error" msgid="3898576754914217248">"始终开启的 VPN 需要服务器和 DNS 的 IP 地址。"</string>
+    <string name="vpn_no_network" msgid="3050233675132726155">"目前没有网络连接。请稍后重试。"</string>
+    <string name="vpn_missing_cert" msgid="7972907102570411501">"证书缺失。请修改配置文件。"</string>
+    <string name="join_two_unrelated_items" msgid="1873827777191260824">"<xliff:g id="FIRST_ITEM">%1$s</xliff:g>、<xliff:g id="SECOND_ITEM">%2$s</xliff:g>"</string>
+    <string name="avaliable_vpns">可用VPN</string>
+    <string name="edit_vpn">编辑VPN</string>
+
+    <!-- Hotpot -->
+    <string name="hotpot_name">热点</string>
+    <string name="hotpot_setting_title">设置WLAN热点</string>
+    <string name="usb_tethering_button_text">USB 网络共享</string>
+    <string name="usb_tethering_available_subtext">USB已连接，点击共享</string>
+    <string name="usb_tethering_active_subtext">已共享</string>
+    <string name="wifi_tether_configure_ap_text">设置WLAN热点</string>
+    <string name="wifi_tether_enabled_subtext">便携式热点 <xliff:g id="network_ssid">%1$s</xliff:g> 已激活</string>
+    <string name="wifi_tether_checkbox_text">便携式WLAN热点</string>
+    <string name="wifi_tether_configure_subtext"><xliff:g id="network_ssid">%1$s</xliff:g> <xliff:g id="network_security">%2$s</xliff:g> 便携式WLAN热点</string>
+    <string name="bluetooth_tethering_available_subtext" product="default">共享网络连接</string>
+    <string name="credentials_password_too_short">密码至少应包含8个字符。</string>
+    <string name="wifi_ssid">网络名称</string>
+    <string name="wifi_security">安全性</string>
+    <string name="wifi_show_password">显示密码</string>
+    <string name="wifi_ap_band_config">选择AP频段</string>
+    <string name="wifi_password">密码</string>
+   <string name="no_button">取消</string>
+   <string name="ok_button">保存</string>
+   <string name="bluetooth_tethering_off_subtext" product="default">不共享网络连接</string>
 </resources>
diff --git a/Settings/res/values/arrays.xml b/Settings/res/values/arrays.xml
index 04384998..7e676554 100755
--- a/Settings/res/values/arrays.xml
+++ b/Settings/res/values/arrays.xml
@@ -318,4 +318,51 @@
         <item>Level 4</item>
         <item>Level 5</item>
     </string-array>
+    <string-array name="surround_sound_entries_spdif" translatable="false">
+        <item>@string/surround_sound_none_summary</item>
+        <item>@string/surround_sound_manual_summary</item>
+    </string-array>
+    <string-array name="surround_sound_entry_values_spdif" translatable="false">
+        <item>never</item>
+        <item>manual</item>
+    </string-array>
+
+    <!-- vpn interface -->
+    <string-array name="vpn_types" translatable="false">
+        <item>PPTP</item>
+        <item>L2TP/IPSec PSK</item>
+        <item>L2TP/IPSec RSA</item>
+        <item>IPSec Xauth PSK</item>
+        <item>IPSec Xauth RSA</item>
+        <item>IPSec Hybrid RSA</item>
+    </string-array>
+    <string-array name="vpn_states">
+        <!-- Status message when VPN is disconnected. -->
+        <item>Disconnected</item>
+        <!-- Status message when VPN is initializing. -->
+        <item>Initializing\u2026</item>
+        <!-- Status message when VPN is connecting. -->
+        <item>Connecting\u2026</item>
+        <!-- Status message when VPN is connected. -->
+        <item>Connected</item>
+        <!-- Status message when VPN is timeout. -->
+        <item>Timeout</item>
+        <!-- Status message when VPN is failed. -->
+        <item>Unsuccessful</item>
+    </string-array>
+
+    <!-- hotpot -->
+    <string-array name="wifi_ap_band_config_2G_only">
+        <item>@string/wifi_ap_choose_2G</item>
+    </string-array>
+
+    <string-array name="wifi_ap_security">
+        <item>@string/wifi_security_none</item>
+        <item>@string/wifi_security_wpa2</item>
+    </string-array>
+
+    <string-array name="wifi_ap_band_config_full">
+        <item>@string/wifi_ap_choose_2G</item>
+        <item>@string/wifi_ap_choose_5G</item>
+    </string-array>
 </resources>
diff --git a/Settings/res/values/strings.xml b/Settings/res/values/strings.xml
index 1f4a710d..d7a03113 100755
--- a/Settings/res/values/strings.xml
+++ b/Settings/res/values/strings.xml
@@ -1926,4 +1926,155 @@
     <string name="autopait_timeout_error">not find device, continue searching</string>
     <string name="pair_fail">remote pairs fail</string>
     <string name="pair_status_error">pair_status_error</string>
+    <!-- VPN interface -->
+    <string name="vpn" >VPN</string>
+    <string name="create_vpn" >Create VPN</string>
+        <!-- Input label for the name of a VPN profile. [CHAR LIMIT=40] -->
+    <string name="vpn_name">Name</string>
+    <!-- Input label for the type of a VPN profile. [CHAR LIMIT=40] -->
+    <string name="vpn_type">Type</string>
+    <!-- Input label for the server address of a VPN profile. [CHAR LIMIT=40] -->
+    <string name="vpn_server">Server address</string>
+    <!-- Checkbox label to enable PPP encryption for a VPN profile. [CHAR LIMIT=40] -->
+    <string name="vpn_mppe">PPP encryption (MPPE)</string>
+    <!-- Input label for the L2TP secret of a VPN profile. [CHAR LIMIT=40] -->
+    <string name="vpn_l2tp_secret">L2TP secret</string>
+    <!-- Input label for the IPSec identifier of a VPN profile. [CHAR LIMIT=40] -->
+    <string name="vpn_ipsec_identifier">IPSec identifier</string>
+    <!-- Input label for the IPSec pre-shared key of a VPN profile. [CHAR LIMIT=40] -->
+    <string name="vpn_ipsec_secret">IPSec pre-shared key</string>
+    <!-- Selection label for the IPSec user certificate of a VPN profile. [CHAR LIMIT=40] -->
+    <string name="vpn_ipsec_user_cert">IPSec user certificate</string>
+    <!-- Selection label for the IPSec CA certificate of a VPN profile. [CHAR LIMIT=40] -->
+    <string name="vpn_ipsec_ca_cert">IPSec CA certificate</string>
+    <!-- Selection label for the IPSec server certificate of a VPN profile. [CHAR LIMIT=40] -->
+    <string name="vpn_ipsec_server_cert">IPSec server certificate</string>
+    <!-- Checkbox label to show advanced options of a VPN profile. [CHAR LIMIT=40] -->
+    <string name="vpn_show_options">Show advanced options</string>
+    <!-- Input label for the DNS search domains of a VPN profile. [CHAR LIMIT=40] -->
+    <string name="vpn_search_domains">DNS search domains</string>
+    <!-- Input label for the DNS servers of a VPN profile. [CHAR LIMIT=40] -->
+    <string name="vpn_dns_servers">DNS servers (e.g. 8.8.8.8)</string>
+    <!-- Input label for the forwarding routes of a VPN profile. [CHAR LIMIT=40] -->
+    <string name="vpn_routes">Forwarding routes (e.g. 10.0.0.0/8)</string>
+    <!-- Input label for the username of a VPN profile. [CHAR LIMIT=40] -->
+    <string name="vpn_username">Username</string>
+    <!-- Input label for the password of a VPN profile. [CHAR LIMIT=40] -->
+    <string name="vpn_password">Password</string>
+    <!-- Checkbox label to save the username and the password in a VPN profile. [CHAR LIMIT=40] -->
+    <string name="vpn_save_login">Save account information</string>
+    <!-- Hint for not using an optional feature in a VPN profile. [CHAR LIMIT=40] -->
+    <string name="vpn_not_used">(not used)</string>
+    <!-- Option to not use a CA certificate to verify the VPN server. [CHAR LIMIT=40] -->
+    <string name="vpn_no_ca_cert">(don\u2019t verify server)</string>
+    <!-- Option to use the server certificate received from the VPN server. [CHAR LIMIT=40] -->
+    <string name="vpn_no_server_cert">(received from server)</string>
+
+    <!-- Button label to cancel changing a VPN profile. [CHAR LIMIT=40] -->
+    <string name="vpn_cancel">Cancel</string>
+    <!-- Button label to finish editing a VPN profile. [CHAR LIMIT=40] -->
+    <string name="vpn_done">Dismiss</string>
+    <!-- Button label to save a VPN profile. [CHAR LIMIT=40] -->
+    <string name="vpn_save">Save</string>
+    <!-- Button label to connect to a VPN profile. [CHAR LIMIT=40] -->
+    <string name="vpn_connect">Connect</string>
+    <!-- Button label to connect a VPN profile, replacing the current one. [CHAR LIMIT=40] -->
+    <string name="vpn_replace">Replace</string>
+    <!-- Dialog title to edit a VPN profile. [CHAR LIMIT=40] -->
+    <string name="vpn_edit">Edit VPN profile</string>
+    <!-- Button label to forget a VPN profile. [CHAR LIMIT=40] -->
+    <string name="vpn_forget">Forget</string>
+    <!-- Dialog title to connect to a VPN profile. [CHAR LIMIT=40] -->
+    <string name="vpn_connect_to">Connect to <xliff:g id="profile" example="School">%s</xliff:g></string>
+    <!-- Dialog message body to disconnect from a VPN profile. -->
+    <string name="vpn_disconnect_confirm">Disconnect this VPN.</string>
+    <!-- Button label to disconnect from a VPN profile. [CHAR LIMIT=40] -->
+    <string name="vpn_disconnect">Disconnect</string>
+    <!-- Field label to show the version number for a VPN app. [CHAR LIMIT=40] -->
+    <string name="vpn_version">Version <xliff:g id="version" example="3.3.0">%s</xliff:g></string>
+    <!-- Button label to forget a VPN profile [CHAR LIMIT=40] -->
+    <string name="vpn_forget_long">Forget VPN</string>
+    <!-- Dialog message title to set another VPN app to be always-on [CHAR LIMIT=40] -->
+    <string name="vpn_replace_always_on_vpn_title">Replace existing VPN?</string>
+    <!-- Dialog message body to set another VPN app to be always-on [CHAR LIMIT=NONE] -->
+    <string name="vpn_replace_always_on_vpn_message">You\'re already connected to a VPN. If you connect to a different one, your existing VPN will be replaced.</string>
+    <!-- Dialog mesage title when the user can't connect an always-on vpn [CHAR LIMIT=NONE] -->
+    <string name="vpn_cant_connect_title"><xliff:g id="vpn_name" example="OpenVPN">%1$s</xliff:g> can\'t connect</string>
+    <!-- Dialog message subtitle when the user can't connect an always-on vpn [CHAR LIMIT=NONE] -->
+    <string name="vpn_cant_connect_message">This app doesn\'t support always-on VPN.</string>
+    <!-- Preference title for VPN settings. [CHAR LIMIT=40] -->
+    <string name="vpn_title">VPN</string>
+    <!-- Preference title to create a new VPN profile. [CHAR LIMIT=40] -->
+    <string name="vpn_create">Add VPN profile</string>
+    <!-- Menu item to edit a VPN profile. [CHAR LIMIT=40] -->
+    <string name="vpn_menu_edit">Edit profile</string>
+    <!-- Menu item to delete a VPN profile. [CHAR LIMIT=40] -->
+    <string name="vpn_menu_delete">Delete profile</string>
+    <!-- Menu item to select always-on VPN profile. [CHAR LIMIT=40] -->
+    <string name="vpn_menu_lockdown">Always-on VPN</string>
+    <!-- Placeholder when VPN settings is open but no VPNs have been created. [CHAR LIMIT=100] -->
+    <string name="vpn_no_vpns_added">No VPNs added.</string>
+    <!-- Preference summary for active always-on vpn [CHAR LIMIT=40] -->
+    <string name="vpn_always_on_active">Always-on active</string>
+    <!-- Preference summary for app not supporting always-on vpn [CHAR LIMIT=NONE] -->
+    <string name="vpn_not_supported_by_this_app">Not supported by this app</string>
+
+    <!-- Summary describing the always-on VPN feature. [CHAR LIMIT=NONE] -->
+    <string name="vpn_lockdown_summary">Select a VPN profile to always remain connected to. Network traffic will only be allowed when connected to this VPN.</string>
+    <!-- List item indicating that no always-on VPN is selected. [CHAR LIMIT=64] -->
+    <string name="vpn_lockdown_none">None</string>
+    <!-- Error indicating that the selected VPN doesn't meet requirements. [CHAR LIMIT=NONE] -->
+    <string name="vpn_lockdown_config_error">Always-on VPN requires an IP address for both server and DNS.</string>
+
+    <!-- Toast message when there is no network connection to start VPN. [CHAR LIMIT=100] -->
+    <string name="vpn_no_network">There is no network connection. Please try again later.</string>
+    <!-- Toast message when a certificate is missing. [CHAR LIMIT=100] -->
+    <string name="vpn_missing_cert">A certificatavaliable_bluetoothe is missing. Please edit the profile.</string>
+    <string name="join_two_unrelated_items"><xliff:g id="first_item">%1$s</xliff:g>, <xliff:g id="second_item">%2$s</xliff:g></string>
+    <string name="avaliable_vpns">Available vpns</string>
+    <string name="edit_vpn">Edit vpn</string>
+    <string name="edit">Edit</string>
+
+    <!-- HotPot -->
+    <string name="hotpot_name">Hotspot</string>
+    <string name="hotpot_setting_title">Hotpot Setup</string>
+    <string name="usb_tethering_active_subtext">Tethered</string>
+	<string name="usb_tethering_available_subtext">USB connected, check to tether</string>
+	<string name="usb_tethering_errored_subtext">USB tethering error</string>
+	<string name="usb_tethering_storage_active_subtext">Can\u2019t tether when USB storage is in use</string>
+	<string name="usb_tethering_unavailable_subtext">USB not connected</string>
+    <string name="bluetooth_tethering_devices_connected_subtext" product="tablet">Sharing this tablet\u2019s Internet connection to <xliff:g id="connectedDeviceCount">%1$d</xliff:g> devices</string>
+    <string name="bluetooth_tethering_devices_connected_subtext" product="default">Sharing this phone\u2019s Internet connection to <xliff:g id="connectedDeviceCount">%1$d</xliff:g> devices</string>
+	<string name="wifi_tether_enabled_subtext">Portable hotspot <xliff:g id="network_ssid">%1$s</xliff:g> active</string>
+	<string name="wifi_error">Error</string>
+	<string name="wifi_tether_starting">Turning hotspot on\u2026</string>
+	<string name="wifi_tether_stopping">Turning off hotspot\u2026</string>
+	<string name="wifi_sap_no_channel_error">5 GHz band not available in this country</string>
+	<string name="wifi_ap_choose_2G">2.4 GHz Band</string>
+	<string name="wifi_ap_choose_5G">5 GHz Band</string>
+	<string name="usb_tethering_button_text">USB tethering</string>
+	<string name="wifi_tether_checkbox_text">Portable Wi\u2011Fi hotspot</string>
+	<string name="wifi_rsdb_checkbox_text">Portable Wi\u2011Fi hotspot(Source from WLAN/RSDB)</string>
+	<string name="wifi_tether_configure_ap_text">Set up Wi\u2011Fi hotspot</string>
+	<string name="bluetooth_tether_checkbox_text">Bluetooth tethering</string>
+    <string name="wifi_tether_configure_subtext"><xliff:g id="network_ssid">%1$s</xliff:g> <xliff:g id="network_security">%2$s</xliff:g> portable Wi\u2011Fi hotspot</string>
+    <string name="bluetooth_tethering_device_connected_subtext" product="tablet">Sharing this tablet\u2019s Internet connection to 1 device</string>
+    <string name="bluetooth_tethering_device_connected_subtext" product="default">Sharing this phone\u2019s Internet connection to 1 device</string>
+    <string name="bluetooth_tethering_errored_subtext">Not tethered</string>
+    <string name="bluetooth_tethering_available_subtext" product="tablet">Sharing this tablet\u2019s Internet connection</string>
+    <!-- Bluetooth available subtext - shown when Bluetooth tethering is turned on but it is not currently tethered to any devices [CHAR LIMIT=50]-->
+    <string name="bluetooth_tethering_available_subtext" product="default">Sharing this phone\u2019s Internet connection</string>
+	<string name="wifi_save">Save</string>
+	<string name="wifi_cancel">Cancel</string>
+	<string name="credentials_password_too_short">The password must have at least 8 characters.</string>
+    <string name="wifi_ssid">Network name</string>
+    <string name="wifi_ssid_hint">Enter the SSID</string>
+    <string name="wifi_security">Security</string>
+    <string name="wifi_password">Password</string>
+    <string name="wifi_show_password">Show password</string>
+	<string name="wifi_ap_band_config">Select AP Band</string>
+	<string name="no_button">Cancel</string>
+	<string name="ok_button">Save</string><string name="bluetooth_tethering_off_subtext" product="tablet">Not sharing this tablet\u2019s Internet connection</string>
+    <!-- Bluetooth tethering off subtext - shown when Bluetooth Tethering is turned off [CHAR LIMIT=50]-->
+    <string name="bluetooth_tethering_off_subtext" product="default">Not sharing this phone\u2019s Internet connection</string>
 </resources>
diff --git a/Settings/res/values/styles.xml b/Settings/res/values/styles.xml
index 9841a18d..5a9716cb 100755
--- a/Settings/res/values/styles.xml
+++ b/Settings/res/values/styles.xml
@@ -289,6 +289,20 @@
     <style name="Setup.GuidedActionItemIcon" parent="@style/Widget.Leanback.GuidedActionItemIconStyle">
         <item name="android:layout_marginEnd">16dp</item>
     </style>
+
+    <style name="vpn_label">
+        <item name="android:layout_width">match_parent</item>
+        <item name="android:layout_height">wrap_content</item>
+        <item name="android:textAppearance">?android:attr/textAppearanceSmall</item>
+    </style>
+
+    <style name="vpn_value">
+        <item name="android:layout_width">match_parent</item>
+        <item name="android:layout_height">wrap_content</item>
+        <item name="android:textAppearance">?android:attr/textAppearanceMedium</item>
+        <item name="android:singleLine">true</item>
+    </style>
+
     <style name="bt_item_label">
         <item name="android:layout_width">wrap_content</item>
         <item name="android:layout_height">wrap_content</item>
@@ -301,4 +315,37 @@
         <item name="android:layout_height">wrap_content</item>
         <item name="android:textSize">18sp</item>
     </style>
+
+    <style name="wifi_section">
+        <item name="android:orientation">vertical</item>
+    </style>
+    <style name="wifi_item">
+        <item name="android:layout_marginTop">8dip</item>
+        <item name="android:layout_marginStart">8dip</item>
+        <item name="android:layout_marginEnd">8dip</item>
+        <item name="android:paddingStart">8dip</item>
+        <item name="android:paddingEnd">8dip</item>
+        <item name="android:orientation">vertical</item>
+        <item name="android:gravity">start</item>
+    </style>
+    <style name="wifi_item_content">
+        <item name="android:textAlignment">viewStart</item>
+        <item name="android:textAppearance">@android:style/TextAppearance.Material.Subhead</item>
+        <item name="android:textColor">?android:attr/textColorPrimary</item>
+    </style>
+
+    <style name="wifi_item_edit_content">
+        <item name="android:paddingStart">4dip</item>
+        <item name="android:layout_marginStart">4dip</item>
+        <item name="android:textSize">18sp</item>
+    </style>
+
+    <style name="wifi_item_label">
+        <item name="android:paddingStart">8dip</item>
+        <item name="android:textSize">14sp</item>
+        <item name="android:textAlignment">viewStart</item>
+        <item name="android:textAppearance">@android:style/TextAppearance.Material.Body1</item>
+        <item name="android:textColor">?android:attr/textColorSecondary</item>
+    </style>
+
 </resources>
diff --git a/Settings/res/xml/hotpot.xml b/Settings/res/xml/hotpot.xml
new file mode 100755
index 00000000..1c53029c
--- /dev/null
+++ b/Settings/res/xml/hotpot.xml
@@ -0,0 +1,33 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<PreferenceScreen xmlns:android="http://schemas.android.com/apk/res/android"
+        xmlns:settings="http://schemas.android.com/apk/res-auto"
+	android:title="@string/hotpot_name"
+		>
+
+    <SwitchPreference
+        android:key="usb_tether_settings"
+        android:title="@string/usb_tethering_button_text" />
+
+    <SwitchPreference
+        android:key="enable_wifi_ap"
+        android:title="@string/wifi_tether_checkbox_text" />
+
+   <SwitchPreference
+	android:key="enable_wifi_rsdb"
+	android:title="@string/wifi_rsdb_checkbox_text" />
+
+    <Preference
+        android:key="wifi_ap_ssid_and_security"
+        android:title="@string/wifi_tether_configure_ap_text"
+        android:persistent="false" >
+		<intent
+        android:targetClass="com.android.tv.settings.connectivity.HotpotDialogActivity"  
+        android:targetPackage="com.android.tv.settings"/>
+	</Preference>
+
+    <SwitchPreference
+        android:key="enable_bluetooth_tethering"
+        android:title="@string/bluetooth_tether_checkbox_text" />
+
+</PreferenceScreen>
diff --git a/Settings/res/xml/network.xml b/Settings/res/xml/network.xml
index a7ab5d3d..ab7c1de7 100755
--- a/Settings/res/xml/network.xml
+++ b/Settings/res/xml/network.xml
@@ -22,6 +22,14 @@
         android:persistent="true"
         android:title="@string/wifi_setting_enable_wifi" />
 
+    <Preference
+            android:key="hotpot"
+            android:title="@string/hotpot_name" >
+        <intent
+            android:targetClass="com.android.tv.settings.connectivity.HotPotActivity"
+            android:targetPackage="com.android.tv.settings" />
+    </Preference>
+
     <com.android.tv.settings.connectivity.CollapsibleCategory
         android:key="wifi_list"
         android:title="@string/wifi_setting_available_networks"
@@ -48,7 +56,7 @@
             android:title="@string/wifi_setting_always_scan"
             android:summary="@string/wifi_setting_always_scan_context" />
     </PreferenceCategory>
-    
+
     <PreferenceCategory
        android:key="mobile_network_category"
        android:title="@string/network_category_title"
@@ -82,4 +90,23 @@
             android:key="ethernet_dhcp"
             android:title="@string/title_wifi_ip_settings" />
     </PreferenceCategory>
+    <PreferenceCategory
+        android:key="vpn"
+        android:title="@string/vpn" >
+         <Preference
+            android:key="vpn_create"
+            android:title="@string/create_vpn" >
+            <intent
+                android:targetClass="com.android.tv.settings.vpn.VpnCreateActivity"
+                android:targetPackage="com.android.tv.settings" />
+        </Preference>
+      <!--   <Preference
+            android:key="edit_vpn"
+            android:title="@string/edit_vpn"
+            android:fragment="com.android.tv.settings.vpn.VpnEditFragment"/> -->
+    </PreferenceCategory>
+
+     <PreferenceCategory
+            android:key="avaliable_vpns"
+            android:title="@string/avaliable_vpns"/>
 </PreferenceScreen>
diff --git a/Settings/src/com/android/tv/settings/connectivity/DialogCreatable.java b/Settings/src/com/android/tv/settings/connectivity/DialogCreatable.java
new file mode 100755
index 00000000..b8a48b77
--- /dev/null
+++ b/Settings/src/com/android/tv/settings/connectivity/DialogCreatable.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tv.settings.connectivity;
+
+import android.app.Dialog;
+
+/**
+ * Letting the class, assumed to be Fragment, create a Dialog on it. Should be useful
+ * you want to utilize some capability in {@link SettingsPreferenceFragment} but don't want
+ * the class inherit the class itself (See {@link ProxySelector} for example).
+ */
+public interface DialogCreatable {
+
+    public Dialog onCreateDialog(int dialogId);
+}
diff --git a/Settings/src/com/android/tv/settings/connectivity/HotPotActivity.java b/Settings/src/com/android/tv/settings/connectivity/HotPotActivity.java
new file mode 100755
index 00000000..0013ea90
--- /dev/null
+++ b/Settings/src/com/android/tv/settings/connectivity/HotPotActivity.java
@@ -0,0 +1,27 @@
+package com.android.tv.settings.connectivity;
+
+import android.app.Fragment;
+
+import com.android.tv.settings.BaseSettingsFragment;
+import com.android.tv.settings.TvSettingsActivity;
+
+public class HotPotActivity extends TvSettingsActivity {
+
+    @Override
+    protected Fragment createSettingsFragment() {
+        return SettingsFragment.newInstance();
+    }
+
+    public static class SettingsFragment extends BaseSettingsFragment {
+
+        public static SettingsFragment newInstance() {
+            return new SettingsFragment();
+        }
+
+        @Override
+        public void onPreferenceStartInitialScreen() {
+            final HotPotFragment fragment = HotPotFragment.newInstance();
+            startPreferenceFragment(fragment);
+        }
+    }
+}
\ No newline at end of file
diff --git a/Settings/src/com/android/tv/settings/connectivity/HotPotFragment.java b/Settings/src/com/android/tv/settings/connectivity/HotPotFragment.java
new file mode 100755
index 00000000..359d6f67
--- /dev/null
+++ b/Settings/src/com/android/tv/settings/connectivity/HotPotFragment.java
@@ -0,0 +1,751 @@
+package com.android.tv.settings.connectivity;
+
+import android.support.v17.preference.LeanbackPreferenceFragment;
+import android.app.Activity;
+import android.app.ActivityManager;
+import android.app.Dialog;
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothPan;
+import android.bluetooth.BluetoothProfile;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.pm.PackageManager;
+import android.hardware.usb.UsbManager;
+import android.net.ConnectivityManager;
+import android.net.wifi.WifiConfiguration;
+import android.net.wifi.WifiManager;
+import android.os.SystemProperties;
+
+import android.os.Bundle;
+import android.os.Environment;
+import android.os.Handler;
+import android.os.UserManager;
+import android.support.v14.preference.SwitchPreference;
+import android.support.v7.preference.Preference;
+import android.support.v7.preference.PreferenceScreen;
+import android.util.Log;
+
+import android.app.DialogFragment;
+import android.app.Fragment;
+import java.io.IOException;
+import java.io.BufferedReader;
+import java.io.InputStreamReader;
+
+
+
+
+
+import com.android.tv.settings.R;
+import com.android.internal.logging.nano.MetricsProto.MetricsEvent;
+
+
+import com.android.settingslib.TetherUtil;
+
+
+import java.lang.ref.WeakReference;
+import java.util.ArrayList;
+import java.util.concurrent.atomic.AtomicReference;
+
+import static android.net.ConnectivityManager.TETHERING_BLUETOOTH;
+import static android.net.ConnectivityManager.TETHERING_USB;
+import static android.net.ConnectivityManager.TETHERING_WIFI;
+
+public class HotPotFragment extends LeanbackPreferenceFragment
+        implements Preference.OnPreferenceChangeListener,
+        DialogInterface.OnClickListener, DialogCreatable {
+
+    private static final String USB_TETHER_SETTINGS = "usb_tether_settings";
+    private static final String ENABLE_WIFI_AP = "enable_wifi_ap";
+    private static final String ENABLE_WIFI_RSDB = "enable_wifi_rsdb";
+    private static final String ENABLE_BLUETOOTH_TETHERING = "enable_bluetooth_tethering";
+    private static final String TETHER_CHOICE = "TETHER_TYPE";
+    private static final String DATA_SAVER_FOOTER = "disabled_on_data_saver";
+
+    private static final int DIALOG_AP_SETTINGS = 1;
+
+    private static final String TAG = "TetheringSettings";
+
+    private SwitchPreference mUsbTether;
+
+    private WifiApEnabler mWifiApEnabler;
+    private SwitchPreference mEnableWifiAp;
+    private SwitchPreference mEnableWifiRsdb;
+    private SwitchPreference mBluetoothTether;
+
+    private BroadcastReceiver mTetherChangeReceiver;
+
+    private String[] mUsbRegexs;
+
+    private String[] mWifiRegexs;
+
+    private String[] mBluetoothRegexs;
+    private AtomicReference<BluetoothPan> mBluetoothPan = new AtomicReference<BluetoothPan>();
+
+    private Handler mHandler = new Handler();
+    private OnStartTetheringCallback mStartTetheringCallback;
+
+    private static final String WIFI_AP_SSID_AND_SECURITY = "wifi_ap_ssid_and_security";
+    private static final int CONFIG_SUBTEXT = R.string.wifi_tether_configure_subtext;
+
+    private String[] mSecurityType;
+    private Preference mCreateNetwork;
+
+    private WifiApDialog mDialog;
+    private WifiManager mWifiManager;
+    private WifiConfiguration mWifiConfig = null;
+    private ConnectivityManager mCm;
+
+    public static boolean mRestartWifiApAfterConfigChange;
+    public static boolean mRestartRsdbAfterConfigChange;
+
+    private boolean mUsbConnected;
+    private boolean mMassStorageActive;
+
+    private boolean mBluetoothEnableForTether;
+
+    /* Stores the package name and the class name of the provisioning app */
+    private String[] mProvisionApp;
+    private static final int PROVISION_REQUEST = 0;
+
+    private boolean mUnavailable;
+
+    private boolean mDataSaverEnabled;
+    private Preference mDataSaverFooter;
+    private int mDelayTimeBeforRestartWifiAp = 1000; // ms
+    private final String PROP_RSDB_NAME = "persist.sys.wifi.rsdb.name";
+    private final String PROP_RSDB_PASSWD = "persist.sys.wifi.rsdb.passwd";
+    private final String PROP_RSDB_SECURITY_TYPE = "persist.sys.wifi.rsdb.security.type";
+    private final String PROP_RSDB_APBAND = "persist.sys.wifi.rsdb.apband";
+    private final String PROP_RSDB_ENABLE = "sys.wifi.rsdb.enable";
+    private final String PROP_WIFIAP_ENABLE = "sys.wifi.wifiap.enable";
+    private final IntentFilter mIntentFilter = new IntentFilter();
+    //private boolean hasRsdb;
+    private boolean mRsdbEnabled;
+    private int mRsdbNetId;
+    public static final int OPEN_INDEX = 0;
+    public static final int WPA2_INDEX = 1;
+
+    public static HotPotFragment newInstance() {
+        return new HotPotFragment();
+    }
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        addPreferencesFromResource(R.xml.hotpot);
+
+        mDataSaverFooter = findPreference(DATA_SAVER_FOOTER);
+
+        final Activity activity = getActivity();
+        BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
+        if (adapter != null) {
+            adapter.getProfileProxy(activity.getApplicationContext(), mProfileServiceListener,
+                    BluetoothProfile.PAN);
+        }
+
+        mEnableWifiAp =
+                (SwitchPreference) findPreference(ENABLE_WIFI_AP);
+        mEnableWifiRsdb = (SwitchPreference) findPreference(ENABLE_WIFI_RSDB);
+        String rsdbenable = SystemProperties.get(PROP_RSDB_ENABLE, "0");
+        String wifienable = SystemProperties.get(PROP_WIFIAP_ENABLE, "0");
+        if(rsdbenable.equals("1")){
+          mEnableWifiRsdb.setChecked(true);
+        }
+        if(wifienable.equals("1")){
+          mEnableWifiAp.setChecked(true);
+        }
+        Preference wifiApSettings = findPreference(WIFI_AP_SSID_AND_SECURITY);
+        mUsbTether = (SwitchPreference) findPreference(USB_TETHER_SETTINGS);
+        mBluetoothTether = (SwitchPreference) findPreference(ENABLE_BLUETOOTH_TETHERING);
+
+        mCm = (ConnectivityManager) getActivity().getSystemService(Context.CONNECTIVITY_SERVICE);
+        mWifiManager = (WifiManager) getActivity().getSystemService(Context.WIFI_SERVICE);
+
+    /*  String model = SystemProperties.get("persist.sys.wifi.model", "6212");
+        if (model.equals("6359")) {
+            hasRsdb = true;
+        } else {
+            hasRsdb = true;
+        }
+        if (hasRsdb) {
+
+        } else {
+            getPreferenceScreen().removePreference(mEnableWifiRsdb);
+        }*/
+
+        mUsbRegexs = mCm.getTetherableUsbRegexs();
+        mWifiRegexs = mCm.getTetherableWifiRegexs();
+        mBluetoothRegexs = mCm.getTetherableBluetoothRegexs();
+
+        final boolean usbAvailable = mUsbRegexs.length != 0;
+        final boolean wifiAvailable = mWifiRegexs.length != 0;
+        final boolean bluetoothAvailable = mBluetoothRegexs.length != 0;
+
+        Log.i(TAG," usbAvailable = " + usbAvailable + "   wifiAvailable = " + wifiAvailable + "  bluetoothAvailable = " + bluetoothAvailable);
+
+        if (!usbAvailable || ActivityManager.isUserAMonkey()) {
+            getPreferenceScreen().removePreference(mUsbTether);
+        }
+
+        if (wifiAvailable && !ActivityManager.isUserAMonkey()) {
+            mWifiApEnabler = new WifiApEnabler(activity, mEnableWifiAp);
+            initWifiTethering();
+        } else {
+            getPreferenceScreen().removePreference(mEnableWifiAp);
+            getPreferenceScreen().removePreference(wifiApSettings);
+        }
+
+        if (!bluetoothAvailable) {
+            getPreferenceScreen().removePreference(mBluetoothTether);
+        } else {
+            BluetoothPan pan = mBluetoothPan.get();
+            if (pan != null && pan.isTetheringOn()) {
+                mBluetoothTether.setChecked(true);
+            } else {
+                mBluetoothTether.setChecked(false);
+            }
+        }
+    }
+
+    @Override
+    public void onCreatePreferences(Bundle savedInstanceState, String rootKey) {
+//        setPreferencesFromResource(R.xml.hotpot, null);
+    }
+
+    @Override
+    public Dialog onCreateDialog(int id) {
+        if (id == DIALOG_AP_SETTINGS) {
+            final Activity activity = getActivity();
+            //           mDialog = new WifiApDialog(activity, this, mWifiConfig);
+            return mDialog;
+        }
+
+        return null;
+    }
+
+    public static boolean isProvisioningNeededButUnavailable(Context context) {
+        return (TetherUtil.isProvisioningNeeded(context)
+                && !isIntentAvailable(context));
+    }
+
+    private static boolean isIntentAvailable(Context context) {
+        String[] provisionApp = context.getResources().getStringArray(
+                com.android.internal.R.array.config_mobile_hotspot_provision_app);
+        if (provisionApp.length < 2) {
+            return false;
+        }
+        final PackageManager packageManager = context.getPackageManager();
+        Intent intent = new Intent(Intent.ACTION_MAIN);
+        intent.setClassName(provisionApp[0], provisionApp[1]);
+        return (packageManager.queryIntentActivities(intent,
+                PackageManager.MATCH_DEFAULT_ONLY).size() > 0);
+    }
+
+    @Override
+    public void onStart() {
+        super.onStart();
+        final Activity activity = getActivity();
+        Log.d("TetheringSettings", "onStart");
+        mStartTetheringCallback = new OnStartTetheringCallback(this);
+
+        mMassStorageActive = Environment.MEDIA_SHARED.equals(Environment.getExternalStorageState());
+        mTetherChangeReceiver = new TetherChangeReceiver();
+        IntentFilter filter = new IntentFilter(ConnectivityManager.ACTION_TETHER_STATE_CHANGED);
+        filter.addAction(WifiManager.WIFI_AP_STATE_CHANGED_ACTION);
+        Intent intent = activity.registerReceiver(mTetherChangeReceiver, filter);
+
+        filter = new IntentFilter();
+        filter.addAction(UsbManager.ACTION_USB_STATE);
+        activity.registerReceiver(mTetherChangeReceiver, filter);
+
+        filter = new IntentFilter();
+        filter.addAction(Intent.ACTION_MEDIA_SHARED);
+        filter.addAction(Intent.ACTION_MEDIA_UNSHARED);
+        filter.addDataScheme("file");
+        activity.registerReceiver(mTetherChangeReceiver, filter);
+
+        filter = new IntentFilter();
+        filter.addAction(BluetoothAdapter.ACTION_STATE_CHANGED);
+        activity.registerReceiver(mTetherChangeReceiver, filter);
+
+        if (intent != null) mTetherChangeReceiver.onReceive(activity, intent);
+        if (mWifiApEnabler != null) {
+            mEnableWifiAp.setOnPreferenceChangeListener(this);
+            mWifiApEnabler.resume();
+        }
+
+        mEnableWifiAp.setChecked(mRestartWifiApAfterConfigChange);
+        //if (hasRsdb)
+        mEnableWifiRsdb.setOnPreferenceChangeListener(this);
+        if(mRestartRsdbAfterConfigChange){
+        try{
+            Log.d("TetheringSettings", "rsdb config change restart softap");
+            Runtime run = Runtime.getRuntime();
+            run.exec("./vendor/bin/start_softap.sh");
+            }catch (IOException e) {
+            // TODO Auto-generated catch block
+            e.printStackTrace();
+           }
+        }
+        mRestartRsdbAfterConfigChange = false;
+        updateState();
+        updateCreateNetwork();
+    }
+
+    @Override
+    public void onStop() {
+        super.onStop();
+
+        if (mUnavailable) {
+            return;
+        }
+        getActivity().unregisterReceiver(mTetherChangeReceiver);
+        mTetherChangeReceiver = null;
+        mStartTetheringCallback = null;
+        if (mWifiApEnabler != null) {
+            mEnableWifiAp.setOnPreferenceChangeListener(null);
+            mWifiApEnabler.pause();
+        }
+    }
+
+    @Override
+    public void onDestroy() {
+        super.onDestroy();
+    }
+
+    private void initWifiTethering() {
+
+        final Activity activity = getActivity();
+        mWifiConfig = mWifiManager.getWifiApConfiguration();
+        mSecurityType = getResources().getStringArray(R.array.wifi_ap_security);
+
+        mCreateNetwork = findPreference(WIFI_AP_SSID_AND_SECURITY);
+
+        mRestartWifiApAfterConfigChange = false;
+		mRestartRsdbAfterConfigChange = false;
+
+        if (mWifiConfig == null) {
+            final String s = activity.getString(
+                    com.android.internal.R.string.wifi_tether_configure_ssid_default);
+            mCreateNetwork.setSummary(String.format(activity.getString(CONFIG_SUBTEXT),
+                    s, mSecurityType[WifiApDialog.OPEN_INDEX]));
+        } else {
+            int index = WifiApDialog.getSecurityTypeIndex(mWifiConfig);
+            mCreateNetwork.setSummary(String.format(activity.getString(CONFIG_SUBTEXT),
+                    mWifiConfig.SSID,
+                    mSecurityType[index]));
+        }
+
+    }
+
+     private void initWifiRsdb() {
+         final Activity activity = getActivity();
+         mWifiConfig = mWifiManager.getWifiApConfiguration();
+         mSecurityType = getResources().getStringArray(R.array.wifi_ap_security);
+         if (mWifiConfig != null) {
+            SystemProperties.set(PROP_RSDB_NAME, mWifiConfig.SSID);
+            SystemProperties.set(PROP_RSDB_PASSWD, mWifiConfig.preSharedKey);
+            if (WifiApDialog.getSecurityTypeIndex(mWifiConfig) == WPA2_INDEX)
+            {
+                SystemProperties.set(PROP_RSDB_SECURITY_TYPE, "wpa2-psk");
+            } else {
+				SystemProperties.set(PROP_RSDB_SECURITY_TYPE, "open");
+            }
+            if(mWifiConfig.apBand == 0)
+            {
+                Log.d("TetheringSettings", "2.4G set");
+                SystemProperties.set(PROP_RSDB_APBAND, "6");//2.4G
+            } else {
+                Log.d("TetheringSettings", "5G  set");
+				SystemProperties.set(PROP_RSDB_APBAND, "48");//5G
+            }
+         }
+     }
+
+	 private void updateCreateNetwork() {
+	     final Activity activity = getActivity();
+	      mWifiConfig = mWifiManager.getWifiApConfiguration();
+	      int index = WifiApDialog.getSecurityTypeIndex(mWifiConfig);
+            mCreateNetwork.setSummary(String.format(activity.getString(CONFIG_SUBTEXT),
+                    mWifiConfig.SSID,
+                    mSecurityType[index]));
+     }
+
+    private class TetherChangeReceiver extends BroadcastReceiver {
+        @Override
+        public void onReceive(Context content, Intent intent) {
+            String action = intent.getAction();
+            if (action.equals(ConnectivityManager.ACTION_TETHER_STATE_CHANGED)) {
+                // TODO - this should understand the interface types
+                ArrayList<String> available = intent.getStringArrayListExtra(
+                        ConnectivityManager.EXTRA_AVAILABLE_TETHER);
+                ArrayList<String> active = intent.getStringArrayListExtra(
+                        ConnectivityManager.EXTRA_ACTIVE_TETHER);
+                ArrayList<String> errored = intent.getStringArrayListExtra(
+                        ConnectivityManager.EXTRA_ERRORED_TETHER);
+                updateState(available.toArray(new String[available.size()]),
+                        active.toArray(new String[active.size()]),
+                        errored.toArray(new String[errored.size()]));
+                if (mWifiManager.getWifiApState() == WifiManager.WIFI_AP_STATE_DISABLED
+                        && mRestartWifiApAfterConfigChange) {
+                    mRestartWifiApAfterConfigChange = false;
+                    Log.d(TAG, "Restarting WifiAp due to prior config change.");
+                    try {
+                        Log.d(TAG, "Sleep " + mDelayTimeBeforRestartWifiAp + "ms befor restarting WifiAp.");
+                        Thread.sleep(mDelayTimeBeforRestartWifiAp);
+                    } catch (InterruptedException ignore) {
+                    }
+                    startTethering(TETHERING_WIFI);
+                }else if(mWifiManager.getWifiApState() == WifiManager.WIFI_AP_STATE_ENABLED
+                    && mRestartWifiApAfterConfigChange)
+                {
+                    mRestartWifiApAfterConfigChange = false;
+                    Log.d(TAG, "Restarting WifiAp due to prior config change.");
+                    mCm.stopTethering(TETHERING_WIFI);
+                    try {
+                    Log.d(TAG, "Sleep " + mDelayTimeBeforRestartWifiAp + "ms befor restarting WifiAp.");
+                        Thread.sleep(mDelayTimeBeforRestartWifiAp);
+                    } catch (InterruptedException ignore) {
+                    }
+                    startTethering(TETHERING_WIFI);
+                }
+            } else if (action.equals(WifiManager.WIFI_AP_STATE_CHANGED_ACTION)) {
+                int state = intent.getIntExtra(WifiManager.EXTRA_WIFI_AP_STATE, 0);
+                if (state == WifiManager.WIFI_AP_STATE_DISABLED
+                        && mRestartWifiApAfterConfigChange) {
+                    mRestartWifiApAfterConfigChange = false;
+                    Log.d(TAG, "Restarting WifiAp due to prior config change.");
+                    try {
+                        Log.d(TAG, "Sleep " + mDelayTimeBeforRestartWifiAp + "ms befor restarting WifiAp.");
+                        Thread.sleep(mDelayTimeBeforRestartWifiAp);
+                    } catch (InterruptedException ignore) {
+                    }
+                    startTethering(TETHERING_WIFI);
+                }
+            } else if (action.equals(Intent.ACTION_MEDIA_SHARED)) {
+                mMassStorageActive = true;
+                updateState();
+            } else if (action.equals(Intent.ACTION_MEDIA_UNSHARED)) {
+                mMassStorageActive = false;
+                updateState();
+            } else if (action.equals(UsbManager.ACTION_USB_STATE)) {
+                mUsbConnected = intent.getBooleanExtra(UsbManager.USB_CONNECTED, false);
+                updateState();
+            } else if (action.equals(BluetoothAdapter.ACTION_STATE_CHANGED)) {
+                if (mBluetoothEnableForTether) {
+                    switch (intent
+                            .getIntExtra(BluetoothAdapter.EXTRA_STATE, BluetoothAdapter.ERROR)) {
+                        case BluetoothAdapter.STATE_ON:
+                            startTethering(TETHERING_BLUETOOTH);
+                            mBluetoothEnableForTether = false;
+                            break;
+
+                        case BluetoothAdapter.STATE_OFF:
+                        case BluetoothAdapter.ERROR:
+                            mBluetoothEnableForTether = false;
+                            break;
+
+                        default:
+                            // ignore transition states
+                    }
+                }
+                updateState();
+            }
+        }
+    }
+
+    public void startTethering(int choice) {
+        if (choice == TETHERING_BLUETOOTH) {
+            // Turn on Bluetooth first.
+            BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
+            if (adapter == null) {
+                return;
+            }
+            if (adapter.getState() == BluetoothAdapter.STATE_OFF) {
+                mBluetoothEnableForTether = true;
+                adapter.enable();
+                mBluetoothTether.setSummary(R.string.bluetooth_turning_on);
+                mBluetoothTether.setEnabled(false);
+                return;
+            }
+        }
+
+        mCm.startTethering(choice, true, mStartTetheringCallback, mHandler);
+    }
+
+    @Override
+    public boolean onPreferenceTreeClick(Preference preference) {
+        if (preference == mUsbTether) {
+            if (mUsbTether.isChecked()) {
+                startTethering(TETHERING_USB);
+            } else {
+                mCm.stopTethering(TETHERING_USB);
+            }
+        } else if (preference == mBluetoothTether) {
+            if (mBluetoothTether.isChecked()) {
+                startTethering(TETHERING_BLUETOOTH);
+            } else {
+                mCm.stopTethering(TETHERING_BLUETOOTH);
+                // No ACTION_TETHER_STATE_CHANGED is fired or bluetooth unless a device is
+                // connected. Need to update state manually.
+                updateState();
+            }
+        } else if (preference == mCreateNetwork) {
+            //           showDialog(DIALOG_AP_SETTINGS);
+        }
+
+        return super.onPreferenceTreeClick(preference);
+    }
+  /*
+    @Override
+    public boolean onPreferenceChange(Preference preference, Object value) {
+        boolean enable = (Boolean) value;
+
+        if (enable) {
+            startTethering(TETHERING_WIFI);
+        } else {
+            mCm.stopTethering(TETHERING_WIFI);
+        }
+        return false;
+    }
+   */
+	@Override
+    public boolean onPreferenceChange(Preference preference, Object value) {
+        boolean enable = (Boolean) value;
+		BufferedReader br = null;
+		Runtime runtime = Runtime.getRuntime();
+        final String key = preference.getKey();
+		Log.d(TAG, " onPreferenceChange : " + value);
+        if (ENABLE_WIFI_AP.equals(key)) {
+           if (enable) {
+                Log.d(TAG, " onPreferenceChange stop rsdb" );
+                mEnableWifiRsdb.setChecked(false);
+			try{
+			    Process p = Runtime.getRuntime().exec("ndc netd 6002 softap stopap");
+              }catch (IOException e) {
+                // TODO Auto-generated catch block
+                e.printStackTrace();
+            }
+		     startTethering(TETHERING_WIFI);
+			 if(mWifiManager.getWifiApState() == WifiManager.WIFI_AP_STATE_ENABLED){
+			 Log.d(TAG, " onPreferenceChange start wifiap sucess");
+			 SystemProperties.set(PROP_WIFIAP_ENABLE, "1");
+			 }
+
+           } else {
+             mCm.stopTethering(TETHERING_WIFI);
+			 SystemProperties.set(PROP_WIFIAP_ENABLE, "0");
+           }
+         } else if (ENABLE_WIFI_RSDB.equals(key)) {
+            if (enable){
+			 mEnableWifiRsdb.setChecked(true);
+             mEnableWifiAp.setChecked(false);
+			 if(mWifiManager.getWifiApState() == WifiManager.WIFI_AP_STATE_ENABLED){
+			      Log.d(TAG, " onPreferenceChange disable wifiap " );
+			      mCm.stopTethering(TETHERING_WIFI);
+			 }
+			 initWifiRsdb();
+			 Log.d(TAG, " onPreferenceChange start rsdb" );
+			 try{
+			      Runtime run = Runtime.getRuntime();
+			      run.exec("./vendor/bin/start_softap.sh");
+            }catch (IOException e) {
+            // TODO Auto-generated catch block
+                  e.printStackTrace();
+              }
+			SystemProperties.set(PROP_RSDB_ENABLE, "1");
+           } else {
+		          mEnableWifiRsdb.setChecked(false);
+			      Log.d(TAG, " onPreferenceChange stop rsdb" );
+			 try{
+			      Process p = Runtime.getRuntime().exec("ndc netd 6002 softap stopap");
+            }catch (IOException e) {
+                 // TODO Auto-generated catch block
+                  e.printStackTrace();
+              }
+			SystemProperties.set(PROP_RSDB_ENABLE, "0");
+           }
+         }
+        return false;
+    }
+
+    private BluetoothProfile.ServiceListener mProfileServiceListener =
+            new BluetoothProfile.ServiceListener() {
+                public void onServiceConnected(int profile, BluetoothProfile proxy) {
+                    mBluetoothPan.set((BluetoothPan) proxy);
+                }
+
+                public void onServiceDisconnected(int profile) {
+                    mBluetoothPan.set(null);
+                }
+            };
+
+    private void updateState() {
+        String[] available = mCm.getTetherableIfaces();
+        String[] tethered = mCm.getTetheredIfaces();
+        String[] errored = mCm.getTetheringErroredIfaces();
+        updateState(available, tethered, errored);
+    }
+
+    private void updateState(String[] available, String[] tethered,
+                             String[] errored) {
+        updateUsbState(available, tethered, errored);
+        updateBluetoothState(available, tethered, errored);
+    }
+
+
+    private void updateUsbState(String[] available, String[] tethered,
+                                String[] errored) {
+        boolean usbAvailable = mUsbConnected && !mMassStorageActive;
+        int usbError = ConnectivityManager.TETHER_ERROR_NO_ERROR;
+        for (String s : available) {
+            for (String regex : mUsbRegexs) {
+                if (s.matches(regex)) {
+                    if (usbError == ConnectivityManager.TETHER_ERROR_NO_ERROR) {
+                        usbError = mCm.getLastTetherError(s);
+                    }
+                }
+            }
+        }
+        boolean usbTethered = false;
+        for (String s : tethered) {
+            for (String regex : mUsbRegexs) {
+                if (s.matches(regex)) usbTethered = true;
+            }
+        }
+        boolean usbErrored = false;
+        for (String s : errored) {
+            for (String regex : mUsbRegexs) {
+                if (s.matches(regex)) usbErrored = true;
+            }
+        }
+
+        if (usbTethered) {
+            mUsbTether.setSummary(R.string.usb_tethering_active_subtext);
+            mUsbTether.setEnabled(!mDataSaverEnabled);
+            mUsbTether.setChecked(true);
+        } else if (usbAvailable) {
+            if (usbError == ConnectivityManager.TETHER_ERROR_NO_ERROR) {
+                mUsbTether.setSummary(R.string.usb_tethering_available_subtext);
+            } else {
+                mUsbTether.setSummary(R.string.usb_tethering_errored_subtext);
+            }
+            mUsbTether.setEnabled(!mDataSaverEnabled);
+            mUsbTether.setChecked(false);
+        } else if (usbErrored) {
+            mUsbTether.setSummary(R.string.usb_tethering_errored_subtext);
+            mUsbTether.setEnabled(false);
+            mUsbTether.setChecked(false);
+        } else if (mMassStorageActive) {
+            mUsbTether.setSummary(R.string.usb_tethering_storage_active_subtext);
+            mUsbTether.setEnabled(false);
+            mUsbTether.setChecked(false);
+        } else {
+            mUsbTether.setSummary(R.string.usb_tethering_unavailable_subtext);
+            mUsbTether.setEnabled(false);
+            mUsbTether.setChecked(false);
+        }
+    }
+
+    private void updateBluetoothState(String[] available, String[] tethered,
+                                      String[] errored) {
+        boolean bluetoothErrored = false;
+        for (String s : errored) {
+            for (String regex : mBluetoothRegexs) {
+                if (s.matches(regex)) bluetoothErrored = true;
+            }
+        }
+
+        BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
+        if (adapter == null) {
+            return;
+        }
+        int btState = adapter.getState();
+        if (btState == BluetoothAdapter.STATE_TURNING_OFF) {
+            mBluetoothTether.setEnabled(false);
+            mBluetoothTether.setSummary(R.string.bluetooth_turning_off);
+        } else if (btState == BluetoothAdapter.STATE_TURNING_ON) {
+            mBluetoothTether.setEnabled(false);
+            mBluetoothTether.setSummary(R.string.bluetooth_turning_on);
+        } else {
+            BluetoothPan bluetoothPan = mBluetoothPan.get();
+            if (btState == BluetoothAdapter.STATE_ON && bluetoothPan != null
+                    && bluetoothPan.isTetheringOn()) {
+                mBluetoothTether.setChecked(true);
+                mBluetoothTether.setEnabled(!mDataSaverEnabled);
+                int bluetoothTethered = bluetoothPan.getConnectedDevices().size();
+                if (bluetoothTethered > 1) {
+                    String summary = getString(
+                            R.string.bluetooth_tethering_devices_connected_subtext,
+                            bluetoothTethered);
+                    mBluetoothTether.setSummary(summary);
+                } else if (bluetoothTethered == 1) {
+                    mBluetoothTether.setSummary(
+                            R.string.bluetooth_tethering_device_connected_subtext);
+                } else if (bluetoothErrored) {
+                    mBluetoothTether.setSummary(R.string.bluetooth_tethering_errored_subtext);
+                } else {
+                    mBluetoothTether.setSummary(R.string.bluetooth_tethering_available_subtext);
+                }
+            } else {
+                mBluetoothTether.setEnabled(!mDataSaverEnabled);
+                mBluetoothTether.setChecked(false);
+                mBluetoothTether.setSummary(R.string.bluetooth_tethering_off_subtext);
+            }
+        }
+    }
+
+    public void onClick(DialogInterface dialogInterface, int button) {
+        if (button == DialogInterface.BUTTON_POSITIVE) {
+            mWifiConfig = mDialog.getConfig();
+            if (mWifiConfig != null) {
+                /**
+                 * if soft AP is stopped, bring up
+                 * else restart with new config
+                 * TODO: update config on a running access point when framework support is added
+                 */
+                if (mWifiManager.getWifiApState() == WifiManager.WIFI_AP_STATE_ENABLED) {
+                    Log.d("TetheringSettings",
+                            "Wifi AP config changed while enabled, stop and restart");
+                    mRestartWifiApAfterConfigChange = true;
+                    mCm.stopTethering(TETHERING_WIFI);
+                }
+                mWifiManager.setWifiApConfiguration(mWifiConfig);
+                int index = WifiApDialog.getSecurityTypeIndex(mWifiConfig);
+                mCreateNetwork.setSummary(String.format(getActivity().getString(CONFIG_SUBTEXT),
+                        mWifiConfig.SSID,
+                        mSecurityType[index]));
+            }
+        }
+    }
+
+    private static final class OnStartTetheringCallback extends
+            ConnectivityManager.OnStartTetheringCallback {
+        final WeakReference<HotPotFragment> mTetherSettings;
+
+        OnStartTetheringCallback(HotPotFragment settings) {
+            mTetherSettings = new WeakReference<HotPotFragment>(settings);
+        }
+
+        @Override
+        public void onTetheringStarted() {
+            update();
+        }
+
+        @Override
+        public void onTetheringFailed() {
+            update();
+        }
+
+        private void update() {
+            HotPotFragment settings = mTetherSettings.get();
+            if (settings != null) {
+                settings.updateState();
+            }
+        }
+    }
+
+}
diff --git a/Settings/src/com/android/tv/settings/connectivity/HotpotDialogActivity.java b/Settings/src/com/android/tv/settings/connectivity/HotpotDialogActivity.java
new file mode 100755
index 00000000..e10ac9c9
--- /dev/null
+++ b/Settings/src/com/android/tv/settings/connectivity/HotpotDialogActivity.java
@@ -0,0 +1,397 @@
+package com.android.tv.settings.connectivity;
+
+import com.android.tv.settings.BaseInputActivity;
+import com.android.tv.settings.R;
+
+import android.app.AlertDialog;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.net.wifi.WifiConfiguration;
+import android.net.wifi.WifiConfiguration.AuthAlgorithm;
+import android.net.wifi.WifiConfiguration.KeyMgmt;
+import android.net.wifi.WifiManager;
+import android.os.Bundle;
+import android.os.SystemProperties;
+import android.text.Editable;
+import android.text.InputType;
+import android.text.TextWatcher;
+import android.util.Log;
+import android.view.View;
+import android.widget.AdapterView;
+import android.widget.ArrayAdapter;
+import android.widget.CheckBox;
+import android.widget.EditText;
+import android.widget.Spinner;
+import android.widget.TextView;
+
+import java.io.*;
+
+import android.widget.Button;
+import android.view.View.OnClickListener;
+import android.net.wifi.WifiConfiguration;
+import android.net.wifi.WifiManager;
+import android.net.ConnectivityManager;
+import android.support.v7.preference.Preference;
+import android.os.Handler;
+import java.io.IOException;
+
+
+
+import android.content.Intent;
+import android.content.BroadcastReceiver;
+
+
+import static android.net.ConnectivityManager.TETHERING_WIFI;
+
+import java.lang.ref.WeakReference;
+
+
+import java.nio.charset.Charset;
+
+public class HotpotDialogActivity extends BaseInputActivity implements View.OnClickListener,
+        TextWatcher, AdapterView.OnItemSelectedListener {
+
+    static final int BUTTON_SUBMIT = DialogInterface.BUTTON_POSITIVE;
+    private static final String DATA_SAVER_FOOTER = "disabled_on_data_saver";
+
+//  private final DialogInterface.OnClickListener mListener;
+
+    public static final int OPEN_INDEX = 0;
+    public static final int WPA2_INDEX = 1;
+
+    private String[] mSecurityType;
+
+    private boolean mDataSaverEnabled;
+
+
+    private ConnectivityManager mCm;
+    private OnStartTetheringCallback mStartTetheringCallback;
+    private Handler mHandler = new Handler();
+
+    private Button my_save_button;
+    private Button my_cancel_button;
+    private Preference mCreateNetwork;
+    private Spinner security;
+
+    private EditText mSsid;
+    private int mSecurityTypeIndex = OPEN_INDEX;
+    private EditText mPassword;
+    private int mBandIndex = OPEN_INDEX;
+
+    WifiConfiguration mWifiConfig;
+    WifiManager mWifiManager;
+    private Context mContext;
+
+    private static final String TAG = "WifiApDialog";
+    private static final String WIFI_AP_SSID_AND_SECURITY = "wifi_ap_ssid_and_security";
+    private final String PROP_RSDB_ENABLE = "sys.wifi.rsdb.enable";
+    private final String PROP_WIFIAP_ENABLE = "sys.wifi.wifiap.enable";
+
+    private final String PROP_RSDB_NAME = "persist.sys.wifi.rsdb.name";
+    private final String PROP_RSDB_PASSWD = "persist.sys.wifi.rsdb.passwd";
+    private final String PROP_RSDB_SECURITY_TYPE = "persist.sys.wifi.rsdb.security.type";
+    private final String PROP_RSDB_APBAND = "persist.sys.wifi.rsdb.apband";
+
+    @Override
+    public void init() {
+        // TODO Auto-generated method stub
+
+    }
+
+    @Override
+    public int getContentLayoutRes() {
+        // TODO Auto-generated method stub
+        return R.layout.wifi_ap_dialog_my;
+    }
+
+    @Override
+    public String getInputTitle() {
+        // TODO Auto-generated method stub
+        return "Hotpot Setup";
+    }
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+
+        super.onCreate(savedInstanceState);
+        mContext = this;
+
+        security = (Spinner) findViewById(R.id.security);
+
+        Spinner mSecurity = ((Spinner) findViewById(R.id.security));
+        final Spinner mChannel = (Spinner) findViewById(R.id.choose_channel);
+
+        mWifiManager = (WifiManager) getSystemService(Context.WIFI_SERVICE);
+        mWifiConfig = mWifiManager.getWifiApConfiguration();
+
+
+        mStartTetheringCallback = new OnStartTetheringCallback(this);
+
+        mSsid = (EditText) findViewById(R.id.ssid);
+        mSsid.requestFocus();
+        mPassword = (EditText) findViewById(R.id.password);
+        my_save_button = (Button) findViewById(R.id.OK);
+        my_cancel_button = (Button) findViewById(R.id.NO);
+
+        my_save_button.setOnClickListener(new myListener());
+        my_cancel_button.setOnClickListener(new myListener());
+
+        ArrayAdapter<CharSequence> channelAdapter;
+        if (mWifiManager.isDualBandSupported()) {
+            channelAdapter = ArrayAdapter.createFromResource(mContext,
+                    R.array.wifi_ap_band_config_full, android.R.layout.simple_spinner_item);
+        } else {
+            channelAdapter = ArrayAdapter.createFromResource(mContext,
+                    R.array.wifi_ap_band_config_2G_only, android.R.layout.simple_spinner_item);
+            mWifiConfig.apBand = 0;
+        }
+        channelAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
+
+        if (mWifiConfig != null) {
+            mSsid.setText(mWifiConfig.SSID);
+            if (mWifiConfig.apBand == 0) {
+                mBandIndex = 0;
+            } else {
+                mBandIndex = 1;
+            }
+
+            security.setSelection(getSecurityTypeIndex(mWifiConfig));
+            if (getSecurityTypeIndex(mWifiConfig) == WPA2_INDEX) {
+                mPassword.setText(mWifiConfig.preSharedKey);
+            }
+        }
+
+        mChannel.setAdapter(channelAdapter);
+        mChannel.setOnItemSelectedListener(
+                new AdapterView.OnItemSelectedListener() {
+                    boolean mInit = true;
+
+                    @Override
+                    public void onItemSelected(AdapterView<?> adapterView, View view, int position,
+                                               long id) {
+                        if (!mInit) {
+                            mBandIndex = position;
+                            mWifiConfig.apBand = mBandIndex;
+                            Log.i(TAG, "config on channelIndex : " + mBandIndex + " Band: " +
+                                    mWifiConfig.apBand);
+                        } else {
+                            mInit = false;
+                            mChannel.setSelection(mBandIndex);
+                        }
+
+                    }
+
+                    @Override
+                    public void onNothingSelected(AdapterView<?> adapterView) {
+
+                    }
+                }
+        );
+
+        mSsid.addTextChangedListener(this);
+        mPassword.addTextChangedListener(this);
+        ((CheckBox) findViewById(R.id.show_password)).setOnClickListener(this);
+        mSecurity.setOnItemSelectedListener(this);
+
+        validate();
+
+    }
+
+    class myListener implements OnClickListener {
+        @Override
+        public void onClick(View view) {
+            switch (view.getId()) {
+                case R.id.OK: {
+                    mWifiConfig = getConfig();
+                    if (mWifiConfig != null) {
+                        if (mWifiManager.getWifiApState() == WifiManager.WIFI_AP_STATE_ENABLED) {
+                            Log.d("TetheringSettings", "++++Wifi AP config changed while enabled, stop and restart");
+                        }
+                        SystemProperties.set("persist.sys.softap.band", String.valueOf(mWifiConfig.apBand));
+                        mWifiManager.setWifiApConfiguration(mWifiConfig);
+                        String rsdbenable = SystemProperties.get(PROP_RSDB_ENABLE, "0");
+                        String wifienable = SystemProperties.get(PROP_WIFIAP_ENABLE, "0");
+                        if (rsdbenable.equals("1")){
+                                Log.d("TetheringSettings", "rsdbenable ");
+								SystemProperties.set(PROP_RSDB_NAME, mWifiConfig.SSID);
+                                SystemProperties.set(PROP_RSDB_PASSWD, mWifiConfig.preSharedKey);
+							 if (getSecurityTypeIndex(mWifiConfig) == WPA2_INDEX) {
+                                SystemProperties.set(PROP_RSDB_SECURITY_TYPE, "wpa2-psk");
+                              }else {
+                                SystemProperties.set(PROP_RSDB_SECURITY_TYPE, "open");
+                              }
+                             if(mWifiConfig.apBand == 0){
+                                Log.d("TetheringSettings", "2.4G set");
+                                SystemProperties.set(PROP_RSDB_APBAND, "6");//2.4G
+                             }else{
+								Log.d("TetheringSettings", "5G  set");
+						        SystemProperties.set(PROP_RSDB_APBAND, "48");//5G
+                             }
+						HotPotFragment.mRestartRsdbAfterConfigChange = true;
+                        }
+                        if (wifienable.equals("1")){
+                        Log.d("TetheringSettings", "wifienable ");
+                        HotPotFragment.mRestartWifiApAfterConfigChange = true;
+                        Intent intent = new Intent();
+                        intent.setAction(ConnectivityManager.ACTION_TETHER_STATE_CHANGED);
+                        sendBroadcast(intent);
+			            }
+                        finish();
+                    }
+                }
+                break;
+                case R.id.NO:
+                    finish();
+                    break;
+            }
+        }
+    }
+
+    private void validate() {
+        String mSsidString = mSsid.getText().toString();
+        if ((mSsid != null && mSsid.length() == 0)
+                || ((mSecurityTypeIndex == WPA2_INDEX) && mPassword.length() < 8)
+                || (mSsid != null &&
+                Charset.forName("UTF-8").encode(mSsidString).limit() > 32)) {
+            my_save_button.setEnabled(false);
+        } else {
+            my_save_button.setEnabled(true);
+        }
+    }
+
+    public static int getSecurityTypeIndex(WifiConfiguration wifiConfig) {
+        if (wifiConfig.allowedKeyManagement.get(KeyMgmt.WPA2_PSK)) {
+            return WPA2_INDEX;
+        }
+        return OPEN_INDEX;
+    }
+
+    public WifiConfiguration getConfig() {
+
+        WifiConfiguration config = new WifiConfiguration();
+
+        /**
+         * TODO: SSID in WifiConfiguration for soft ap
+         * is being stored as a raw string without quotes.
+         * This is not the case on the client side. We need to
+         * make things consistent and clean it up
+         */
+        config.SSID = mSsid.getText().toString();
+
+        config.apBand = mBandIndex;
+
+        switch (mSecurityTypeIndex) {
+            case OPEN_INDEX:
+                config.allowedKeyManagement.set(KeyMgmt.NONE);
+                return config;
+
+            case WPA2_INDEX:
+                config.allowedKeyManagement.set(KeyMgmt.WPA2_PSK);
+                config.allowedAuthAlgorithms.set(AuthAlgorithm.OPEN);
+                if (mPassword.length() != 0) {
+                    String password = mPassword.getText().toString();
+                    config.preSharedKey = password;
+                }
+                return config;
+        }
+        return null;
+    }
+
+    public boolean checkIfSupportDualBand() {
+        File file = new File("/sys/bus/mmc/devices/sdio:0001/sdio:0001:1/device");
+        BufferedReader reader = null;
+
+        try {
+            reader = new BufferedReader(new FileReader(file));
+            String tempString = null;
+            while ((tempString = reader.readLine()) != null) {
+                Log.d(TAG, "Get wifi chip name: " + tempString);
+                if (tempString.contains("0x4359") || tempString.contains("0x6255")
+                        || tempString.contains("0x4356") || tempString.contains("0x4358")) {
+                    reader.close();
+                    return true;
+                }
+            }
+            reader.close();
+        } catch (IOException e) {
+            e.printStackTrace();
+        } finally {
+            if (reader != null) {
+                try {
+                    reader.close();
+                } catch (IOException e1) {
+                }
+            }
+        }
+
+	return false;
+    }
+
+    public void onRestoreInstanceState(Bundle savedInstanceState) {
+        super.onRestoreInstanceState(savedInstanceState);
+        mPassword.setInputType(
+                InputType.TYPE_CLASS_TEXT |
+                        (((CheckBox) findViewById(R.id.show_password)).isChecked() ?
+                                InputType.TYPE_TEXT_VARIATION_VISIBLE_PASSWORD :
+                                InputType.TYPE_TEXT_VARIATION_PASSWORD));
+    }
+
+    public void onClick(View view) {
+        mPassword.setInputType(
+                InputType.TYPE_CLASS_TEXT | (((CheckBox) view).isChecked() ?
+                        InputType.TYPE_TEXT_VARIATION_VISIBLE_PASSWORD :
+                        InputType.TYPE_TEXT_VARIATION_PASSWORD));
+    }
+
+    public void onTextChanged(CharSequence s, int start, int before, int count) {
+    }
+
+    public void beforeTextChanged(CharSequence s, int start, int count, int after) {
+    }
+
+    public void afterTextChanged(Editable editable) {
+        validate();
+    }
+
+    @Override
+    public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
+        mSecurityTypeIndex = position;
+        showSecurityFields();
+        validate();
+    }
+
+    @Override
+    public void onNothingSelected(AdapterView<?> parent) {
+    }
+
+    private void showSecurityFields() {
+        if (mSecurityTypeIndex == OPEN_INDEX) {
+            findViewById(R.id.fields).setVisibility(View.GONE);
+            return;
+        }
+        findViewById(R.id.fields).setVisibility(View.VISIBLE);
+    }
+
+    private static final class OnStartTetheringCallback extends
+            ConnectivityManager.OnStartTetheringCallback {
+        final WeakReference<HotpotDialogActivity> mTetherSettings;
+
+        OnStartTetheringCallback(HotpotDialogActivity settings) {
+            mTetherSettings = new WeakReference<HotpotDialogActivity>(settings);
+        }
+
+        @Override
+        public void onTetheringStarted() {
+            update();
+        }
+
+        @Override
+        public void onTetheringFailed() {
+            update();
+        }
+
+        private void update() {
+
+        }
+    }
+}
diff --git a/Settings/src/com/android/tv/settings/connectivity/NetworkFragment.java b/Settings/src/com/android/tv/settings/connectivity/NetworkFragment.java
index fc8777a8..c6df6b8b 100755
--- a/Settings/src/com/android/tv/settings/connectivity/NetworkFragment.java
+++ b/Settings/src/com/android/tv/settings/connectivity/NetworkFragment.java
@@ -20,6 +20,7 @@ import android.content.Context;
 import android.content.BroadcastReceiver;
 import android.content.Intent;
 import android.content.IntentFilter;
+import android.content.Intent;
 import android.net.wifi.WifiConfiguration;
 import android.os.Bundle;
 import android.os.Handler;
@@ -33,12 +34,36 @@ import android.util.Log;
 import android.text.TextUtils;
 import android.telephony.TelephonyManager;
 
+import android.annotation.UiThread;
+import android.annotation.WorkerThread;
+import android.util.ArrayMap;
+import android.util.ArraySet;
 import com.android.internal.logging.nano.MetricsProto;
 import com.android.settingslib.wifi.AccessPoint;
 import com.android.settingslib.wifi.AccessPointPreference;
 import com.android.tv.settings.R;
+import com.android.tv.settings.data.ConstData;
+import com.android.tv.settings.vpn.*;
 import com.android.tv.settings.SettingsPreferenceFragment;
 import com.android.tv.settings.boardInfo.BoardInfo;
+import android.net.ConnectivityManager.NetworkCallback;
+import android.net.ConnectivityManager;
+import android.net.IConnectivityManager;
+import android.os.Message;
+import android.os.UserHandle;
+import android.os.UserManager;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.os.SystemProperties;
+import com.android.internal.net.LegacyVpnInfo;
+import com.android.internal.net.VpnConfig;
+import com.android.internal.net.VpnProfile;
+import com.android.internal.util.ArrayUtils;
+import com.android.settingslib.RestrictedLockUtils;
+import com.google.android.collect.Lists;
+import android.security.Credentials;
+import android.security.KeyStore;
+import android.util.Log;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
@@ -48,18 +73,25 @@ import java.io.RandomAccessFile;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
+
+
 import java.util.Collection;
 import java.util.HashSet;
+import java.util.Map;
+import java.util.List;
 import java.util.Set;
 import java.io.File;
+import java.util.ArrayList;
+import java.util.Collections;
+
+import static android.app.AppOpsManager.OP_ACTIVATE_VPN;
 
 /**
  * Fragment for controlling network connectivity
  */
 public class NetworkFragment extends SettingsPreferenceFragment implements
         ConnectivityListener.Listener, ConnectivityListener.WifiNetworkListener,
-        AccessPoint.AccessPointListener {
-
+        AccessPoint.AccessPointListener, Preference.OnPreferenceClickListener, Handler.Callback {
     private static final String TAG = "NetworkFragment";
 
     private static final String KEY_WIFI_ENABLE = "wifi_enable";
@@ -75,12 +107,19 @@ public class NetworkFragment extends SettingsPreferenceFragment implements
     private static final String KEY_ETHERNET_PORT = "ethernet_port";
     private static final String KEY_ETHERNET_PROXY = "ethernet_proxy";
     private static final String KEY_ETHERNET_DHCP = "ethernet_dhcp";
+    private static final String KEY_HOTPOT = "hotpot";
+    private static final String KEY_VPN = "avaliable_vpns";
+    private static final String KEY_EDIT_VPN = "edit_vpn";
+
 
     private static final int INITIAL_UPDATE_DELAY = 500;
 
     private static final String BROADCAST_ACTION = "android.action.updateui";
 
     private static final String SYS_ETHERNET_MODE ="/sys/class/mcu/ethernet_mode";
+    private final KeyStore mKeyStore = KeyStore.getInstance();
+    private final IConnectivityManager mConnectivityService = IConnectivityManager.Stub
+            .asInterface(ServiceManager.getService(Context.CONNECTIVITY_SERVICE));
     private ConnectivityListener mConnectivityListener;
     private AccessPointPreference.UserBadgeCache mUserBadgeCache;
 
@@ -93,13 +132,21 @@ public class NetworkFragment extends SettingsPreferenceFragment implements
     private PreferenceCategory mMobileCategory;
     private TwoStatePreference mAlwaysScan;
     private PreferenceCategory mEthernetCategory;
+    private PreferenceCategory mVpnCategory;
     private Preference mEthernetStatusPref;
     private Preference mEthernetProxyPref;
     private Preference mEthernetDhcpPref;
+    private Preference mHotsPot;
 
     private final Handler mHandler = new Handler();
     private long mNoWifiUpdateBeforeMillis;
+    private Preference mVpnCreatePref;
+    private LegacyVpnInfo mConnectedLegacyVpn;
+    private Handler mUpdater;
     private BoardInfo mBoardInfo;
+    private static final int RESCAN_MESSAGE = 0;
+    private static final int RESCAN_INTERVAL_MS = 1000;
+    private Map<String, LegacyVpnPreference> mLegacyVpnPreferences = new ArrayMap<>();
     private Runnable mInitialUpdateWifiListRunnable = new Runnable() {
         @Override
         public void run() {
@@ -150,12 +197,33 @@ public class NetworkFragment extends SettingsPreferenceFragment implements
         // tickle it here and hope for the best.
         mConnectivityListener.updateConnectivityStatus();
         updateConnectivity();
+        if (mUpdater == null) {
+            mUpdater = new Handler(this);
+        }
+        mUpdater.sendEmptyMessage(RESCAN_MESSAGE);
+    }
+
+    @Override
+    public void onPause() {
+        super.onPause();
+        if (mUpdater != null) {
+            mUpdater.removeCallbacksAndMessages(null);
+        }
     }
 
     @Override
     public void onStop() {
         super.onStop();
         getContext().unregisterReceiver(mUIReceiver);
+        mConnectivityListener.stop();
+    }
+
+    @Override
+    public void onDestroy() {
+        super.onDestroy();
+        if (mConnectivityListener != null) {
+            mConnectivityListener.destroy();
+        }
     }
 
     @Override
@@ -172,6 +240,7 @@ public class NetworkFragment extends SettingsPreferenceFragment implements
         mMobileCategory = (PreferenceCategory) findPreference(KEY_MOBILE_CATEGORY);
         mMobilePref = findPreference(KEY_MOBILE_SETTINGS);
         mAlwaysScan = (TwoStatePreference) findPreference(KEY_WIFI_ALWAYS_SCAN);
+        mHotsPot = findPreference(KEY_HOTPOT);
 
         mEthernetCategory = (PreferenceCategory) findPreference(KEY_ETHERNET);
         mEthernetSwitch = (TwoStatePreference) findPreference(KEY_ETHERNET_PORT);
@@ -182,6 +251,13 @@ public class NetworkFragment extends SettingsPreferenceFragment implements
         mEthernetDhcpPref = findPreference(KEY_ETHERNET_DHCP);
         mEthernetDhcpPref.setIntent(EditIpSettingsActivity.createIntent(getContext(),
                 WifiConfiguration.INVALID_NETWORK_ID));
+        mVpnCategory = (PreferenceCategory) findPreference(KEY_VPN);
+        getPreferenceScreen().removePreference(mVpnCategory);
+        getPreferenceScreen().removePreference((PreferenceCategory) findPreference("vpn"));
+        if (!SystemProperties.get("ro.target.product","box").equals("box")) {
+            getPreferenceScreen().removePreference(mHotsPot);
+        }
+
         if (mBoardInfo.isM2xNetSupport()) {
             int mode = getEthernetMode();
             mEthernetSwitch.setChecked(mode==0 ? false:true);
@@ -340,6 +416,54 @@ public class NetworkFragment extends SettingsPreferenceFragment implements
         }
     }
 
+    private void updateVPNList() {
+        getActivity().runOnUiThread(new Runnable() {
+            public void run() {
+
+                List<VpnProfile> vpnProfiles = loadVpnProfiles(mKeyStore);
+                String lockdownVpnKey = VpnUtils.getLockdownVpn();
+                final Set<Preference> updates = new ArraySet<>();
+                Map<String, LegacyVpnInfo> connectedLegacyVpns = getConnectedLegacyVpns();
+                for (VpnProfile profile : vpnProfiles) {
+                    LegacyVpnPreference p = findOrCreatePreference(profile);
+                    if (connectedLegacyVpns.containsKey(profile.key)) {
+                        p.setState(connectedLegacyVpns.get(profile.key).state);
+                    } else {
+                        p.setState(LegacyVpnPreference.STATE_NONE);
+                    }
+                    p.setAlwaysOn(lockdownVpnKey != null && lockdownVpnKey.equals(profile.key));
+                    updates.add(p);
+                }
+                mLegacyVpnPreferences.values().retainAll(updates);
+                for (int i = mVpnCategory.getPreferenceCount() - 1; i >= 0; i--) {
+                    Preference p = mVpnCategory.getPreference(i);
+                    if (updates.contains(p)) {
+                        updates.remove(p);
+                    } /*else if(!"vpn_create".equals(p.getKey())){
+                         mVpnCategory.removePreference(p);
+                     }*/
+                }
+                // Show any new preferences on the screen
+                for (Preference pref : updates) {
+                    mVpnCategory.addPreference(pref);
+                }
+ /*             Preference vpnCreatePref = new Preference(getPreferenceManager().getContext());
+                vpnCreatePref.setTitle(R.string.create_vpn);
+                Intent createVpnIntent = new Intent();
+                createVpnIntent.setClassName(getActivity().getPackageName(), VpnCreateActivity.class.getName());
+                VpnProfile createProfile = new VpnProfile(Long.toHexString(System.currentTimeMillis()));
+                createVpnIntent.putExtra(ConstData.IntentKey.VPN_PROFILE, createProfile);
+                createVpnIntent.putExtra(ConstData.IntentKey.VPN_EXIST, false);
+                createVpnIntent.putExtra(ConstData.IntentKey.VPN_EDITING, true);
+                vpnCreatePref.setIntent(createVpnIntent);
+                mVpnCategory.addPreference(vpnCreatePref);*/
+            }
+
+            ;
+        });
+
+    }
+
     private void updateWifiList() {
         if (!isAdded()) {
             return;
@@ -422,4 +546,103 @@ public class NetworkFragment extends SettingsPreferenceFragment implements
     public int getMetricsCategory() {
         return MetricsProto.MetricsEvent.SETTINGS_NETWORK_CATEGORY;
     }
+
+    static List<VpnProfile> loadVpnProfiles(KeyStore keyStore, int... excludeTypes) {
+        final ArrayList<VpnProfile> result = Lists.newArrayList();
+
+        for (String key : keyStore.list(Credentials.VPN)) {
+            final VpnProfile profile = VpnProfile.decode(key, keyStore.get(Credentials.VPN + key));
+            if (profile != null && !ArrayUtils.contains(excludeTypes, profile.type)) {
+                result.add(profile);
+            }
+        }
+        return result;
+    }
+
+    @WorkerThread
+    private Map<String, LegacyVpnInfo> getConnectedLegacyVpns() {
+        try {
+            mConnectedLegacyVpn = mConnectivityService.getLegacyVpnInfo(UserHandle.myUserId());
+            if (mConnectedLegacyVpn != null) {
+                return Collections.singletonMap(mConnectedLegacyVpn.key, mConnectedLegacyVpn);
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "Failure updating VPN list with connected legacy VPNs", e);
+        }
+        return Collections.emptyMap();
+    }
+
+    @UiThread
+    private LegacyVpnPreference findOrCreatePreference(VpnProfile profile) {
+        LegacyVpnPreference pref = mLegacyVpnPreferences.get(profile.key);
+        if (pref == null) {
+            pref = new LegacyVpnPreference(getPreferenceManager().getContext());
+            //pref.setOnGearClickListener(mGearListener);
+            pref.setOnPreferenceClickListener(this);
+            mLegacyVpnPreferences.put(profile.key, pref);
+        }
+        // This may change as the profile can update and keep the same key.
+        pref.setProfile(profile);
+        return pref;
+    }
+
+    @Override
+    public boolean onPreferenceClick(Preference preference) {
+        if (preference instanceof LegacyVpnPreference) {
+            LegacyVpnPreference pref = (LegacyVpnPreference) preference;
+            VpnProfile profile = pref.getProfile();
+            if (mConnectedLegacyVpn != null && profile.key.equals(mConnectedLegacyVpn.key) &&
+                    mConnectedLegacyVpn.state == LegacyVpnInfo.STATE_CONNECTED) {
+                try {
+                    mConnectedLegacyVpn.intent.send();
+                    return true;
+                } catch (Exception e) {
+                    Log.w(TAG, "Starting config intent failed", e);
+                }
+            }
+            Intent prefIntent = new Intent();
+            prefIntent.setClass(getContext(), VpnCreateActivity.class);
+            prefIntent.putExtra(ConstData.IntentKey.VPN_PROFILE, profile);
+            prefIntent.putExtra(ConstData.IntentKey.VPN_EDITING, false);
+            prefIntent.putExtra(ConstData.IntentKey.VPN_EXIST, true);
+            startActivity(prefIntent);
+            //ConfigDialogFragment.show(this, profile, false /* editing */, true /* exists */);
+            return true;
+        } /*else if (preference instanceof AppPreference) {
+            AppPreference pref = (AppPreference) preference;
+            boolean connected = (pref.getState() == AppPreference.STATE_CONNECTED);
+
+            if (!connected) {
+                try {
+                    UserHandle user = UserHandle.of(pref.getUserId());
+                    Context userContext = getActivity().createPackageContextAsUser(
+                            getActivity().getPackageName(), 0  flags , user);
+                    PackageManager pm = userContext.getPackageManager();
+                    Intent appIntent = pm.getLaunchIntentForPackage(pref.getPackageName());
+                    if (appIntent != null) {
+                        userContext.startActivityAsUser(appIntent, user);
+                        return true;
+                    }
+                } catch (PackageManager.NameNotFoundException nnfe) {
+                    Log.w(LOG_TAG, "VPN provider does not exist: " + pref.getPackageName(), nnfe);
+                }
+            }
+
+            // Already connected or no launch intent available - show an info dialog
+            PackageInfo pkgInfo = pref.getPackageInfo();
+            AppDialogFragment.show(this, pkgInfo, pref.getLabel(), false  editing , connected);
+            return true;
+        }else{
+            createVPN();
+        }*/
+        return false;
+    }
+
+    @Override
+    public boolean handleMessage(Message message) {
+        mUpdater.removeMessages(RESCAN_MESSAGE);
+        updateVPNList();
+        mUpdater.sendEmptyMessageDelayed(RESCAN_MESSAGE, RESCAN_INTERVAL_MS);
+        return true;
+    }
 }
diff --git a/Settings/src/com/android/tv/settings/connectivity/WifiApDialog.java b/Settings/src/com/android/tv/settings/connectivity/WifiApDialog.java
new file mode 100755
index 00000000..4bb1f97f
--- /dev/null
+++ b/Settings/src/com/android/tv/settings/connectivity/WifiApDialog.java
@@ -0,0 +1,278 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tv.settings.connectivity;
+
+import android.app.AlertDialog;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.net.wifi.WifiConfiguration;
+import android.net.wifi.WifiConfiguration.AuthAlgorithm;
+import android.net.wifi.WifiConfiguration.KeyMgmt;
+import android.net.wifi.WifiManager;
+import android.os.Bundle;
+import android.os.SystemProperties;
+import android.text.Editable;
+import android.text.InputType;
+import android.text.TextWatcher;
+import android.util.Log;
+import android.view.View;
+import android.widget.AdapterView;
+import android.widget.ArrayAdapter;
+import android.widget.CheckBox;
+import android.widget.EditText;
+import android.widget.Spinner;
+import android.widget.TextView;
+
+import java.io.*;
+
+import com.android.tv.settings.R;
+
+import java.nio.charset.Charset;
+
+/**
+ * Dialog to configure the SSID and security settings
+ * for Access Point operation
+ */
+public class WifiApDialog extends AlertDialog implements View.OnClickListener,
+        TextWatcher, AdapterView.OnItemSelectedListener {
+
+    static final int BUTTON_SUBMIT = DialogInterface.BUTTON_POSITIVE;
+
+    private final DialogInterface.OnClickListener mListener;
+
+    public static final int OPEN_INDEX = 0;
+    public static final int WPA2_INDEX = 1;
+
+    private View mView;
+    private TextView mSsid;
+    private int mSecurityTypeIndex = OPEN_INDEX;
+    private EditText mPassword;
+    private int mBandIndex = OPEN_INDEX;
+
+    WifiConfiguration mWifiConfig;
+    WifiManager mWifiManager;
+    private Context mContext;
+
+    private static final String TAG = "WifiApDialog";
+
+    public WifiApDialog(Context context, DialogInterface.OnClickListener listener,
+                        WifiConfiguration wifiConfig) {
+        super(context);
+        mListener = listener;
+        mWifiConfig = wifiConfig;
+        if (wifiConfig != null) {
+            mSecurityTypeIndex = getSecurityTypeIndex(wifiConfig);
+        }
+        mWifiManager = (WifiManager) context.getSystemService(Context.WIFI_SERVICE);
+        mContext = context;
+    }
+
+    public static int getSecurityTypeIndex(WifiConfiguration wifiConfig) {
+        if (wifiConfig.allowedKeyManagement.get(KeyMgmt.WPA2_PSK)) {
+            return WPA2_INDEX;
+        }
+        return OPEN_INDEX;
+    }
+
+    public WifiConfiguration getConfig() {
+
+        WifiConfiguration config = new WifiConfiguration();
+
+        /**
+         * TODO: SSID in WifiConfiguration for soft ap
+         * is being stored as a raw string without quotes.
+         * This is not the case on the client side. We need to
+         * make things consistent and clean it up
+         */
+        config.SSID = mSsid.getText().toString();
+
+        config.apBand = mBandIndex;
+
+        switch (mSecurityTypeIndex) {
+            case OPEN_INDEX:
+                config.allowedKeyManagement.set(KeyMgmt.NONE);
+                return config;
+
+            case WPA2_INDEX:
+                config.allowedKeyManagement.set(KeyMgmt.WPA2_PSK);
+                config.allowedAuthAlgorithms.set(AuthAlgorithm.OPEN);
+                if (mPassword.length() != 0) {
+                    String password = mPassword.getText().toString();
+                    config.preSharedKey = password;
+                }
+                return config;
+        }
+        return null;
+    }
+
+    public boolean checkIfSupportDualBand() {
+	/*
+        String model = SystemProperties.get("persist.sys.wifi.model", "AP6212");
+        if (model.equals("AP6255") || model.equals("AP6356S") || model.equals("AP6359") || model.equals("AP6398S")
+            return true;
+        else
+            return false;
+	*/
+	return true;
+    }
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        boolean mInit = true;
+        mView = getLayoutInflater().inflate(R.layout.wifi_ap_dialog_my, null);
+        Spinner mSecurity = ((Spinner) mView.findViewById(R.id.security));
+        final Spinner mChannel = (Spinner) mView.findViewById(R.id.choose_channel);
+
+        setView(mView);
+        setInverseBackgroundForced(true);
+
+        Context context = getContext();
+
+        setTitle(R.string.wifi_tether_configure_ap_text);
+        mView.findViewById(R.id.type).setVisibility(View.VISIBLE);
+        mSsid = (TextView) mView.findViewById(R.id.ssid);
+        mPassword = (EditText) mView.findViewById(R.id.password);
+
+        ArrayAdapter<CharSequence> channelAdapter;
+        String countryCode = mWifiManager.getCountryCode();
+        if (!checkIfSupportDualBand()) {
+            //If no country code, 5GHz AP is forbidden
+            // Log.i(TAG,(!mWifiManager.isDualBandSupported() ? "Device do not support 5GHz " :"")
+            //         + (countryCode == null ? " NO country code" :"") +  " forbid 5GHz");
+            channelAdapter = ArrayAdapter.createFromResource(mContext,
+                    R.array.wifi_ap_band_config_2G_only, android.R.layout.simple_spinner_item);
+            mWifiConfig.apBand = 0;
+        } else {
+            channelAdapter = ArrayAdapter.createFromResource(mContext,
+                    R.array.wifi_ap_band_config_full, android.R.layout.simple_spinner_item);
+        }
+
+        channelAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
+
+        setButton(BUTTON_SUBMIT, context.getString(R.string.wifi_save), mListener);
+        setButton(DialogInterface.BUTTON_NEGATIVE,
+                context.getString(R.string.wifi_cancel), mListener);
+
+        if (mWifiConfig != null) {
+            mSsid.setText(mWifiConfig.SSID);
+            if (mWifiConfig.apBand == 0) {
+                mBandIndex = 0;
+            } else {
+                mBandIndex = 1;
+            }
+
+            mSecurity.setSelection(mSecurityTypeIndex);
+            if (mSecurityTypeIndex == WPA2_INDEX) {
+                mPassword.setText(mWifiConfig.preSharedKey);
+            }
+        }
+
+        mChannel.setAdapter(channelAdapter);
+        mChannel.setOnItemSelectedListener(
+                new AdapterView.OnItemSelectedListener() {
+                    boolean mInit = true;
+
+                    @Override
+                    public void onItemSelected(AdapterView<?> adapterView, View view, int position,
+                                               long id) {
+                        if (!mInit) {
+                            mBandIndex = position;
+                            mWifiConfig.apBand = mBandIndex;
+                            Log.i(TAG, "config on channelIndex : " + mBandIndex + " Band: " +
+                                    mWifiConfig.apBand);
+                        } else {
+                            mInit = false;
+                            mChannel.setSelection(mBandIndex);
+                        }
+
+                    }
+
+                    @Override
+                    public void onNothingSelected(AdapterView<?> adapterView) {
+
+                    }
+                }
+        );
+
+        mSsid.addTextChangedListener(this);
+        mPassword.addTextChangedListener(this);
+        ((CheckBox) mView.findViewById(R.id.show_password)).setOnClickListener(this);
+        mSecurity.setOnItemSelectedListener(this);
+
+        super.onCreate(savedInstanceState);
+
+        showSecurityFields();
+        validate();
+    }
+
+    public void onRestoreInstanceState(Bundle savedInstanceState) {
+        super.onRestoreInstanceState(savedInstanceState);
+        mPassword.setInputType(
+                InputType.TYPE_CLASS_TEXT |
+                        (((CheckBox) mView.findViewById(R.id.show_password)).isChecked() ?
+                                InputType.TYPE_TEXT_VARIATION_VISIBLE_PASSWORD :
+                                InputType.TYPE_TEXT_VARIATION_PASSWORD));
+    }
+
+    private void validate() {
+        String mSsidString = mSsid.getText().toString();
+        if ((mSsid != null && mSsid.length() == 0)
+                || ((mSecurityTypeIndex == WPA2_INDEX) && mPassword.length() < 8)
+                || (mSsid != null &&
+                Charset.forName("UTF-8").encode(mSsidString).limit() > 32)) {
+            getButton(BUTTON_SUBMIT).setEnabled(false);
+        } else {
+            getButton(BUTTON_SUBMIT).setEnabled(true);
+        }
+    }
+
+    public void onClick(View view) {
+        mPassword.setInputType(
+                InputType.TYPE_CLASS_TEXT | (((CheckBox) view).isChecked() ?
+                        InputType.TYPE_TEXT_VARIATION_VISIBLE_PASSWORD :
+                        InputType.TYPE_TEXT_VARIATION_PASSWORD));
+    }
+
+    public void onTextChanged(CharSequence s, int start, int before, int count) {
+    }
+
+    public void beforeTextChanged(CharSequence s, int start, int count, int after) {
+    }
+
+    public void afterTextChanged(Editable editable) {
+        validate();
+    }
+
+    @Override
+    public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
+        mSecurityTypeIndex = position;
+        showSecurityFields();
+        validate();
+    }
+
+    @Override
+    public void onNothingSelected(AdapterView<?> parent) {
+    }
+
+    private void showSecurityFields() {
+        if (mSecurityTypeIndex == OPEN_INDEX) {
+            mView.findViewById(R.id.fields).setVisibility(View.GONE);
+            return;
+        }
+        mView.findViewById(R.id.fields).setVisibility(View.VISIBLE);
+    }
+}
diff --git a/Settings/src/com/android/tv/settings/connectivity/WifiApEnabler.java b/Settings/src/com/android/tv/settings/connectivity/WifiApEnabler.java
new file mode 100755
index 00000000..d83c505e
--- /dev/null
+++ b/Settings/src/com/android/tv/settings/connectivity/WifiApEnabler.java
@@ -0,0 +1,180 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tv.settings.connectivity;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.net.ConnectivityManager;
+import android.net.wifi.WifiConfiguration;
+import android.net.wifi.WifiManager;
+import android.provider.Settings;
+import android.support.v14.preference.SwitchPreference;
+import android.util.Log;
+
+import com.android.tv.settings.R;
+import com.android.settingslib.TetherUtil;
+
+import java.util.ArrayList;
+
+public class WifiApEnabler {
+    private final Context mContext;
+    private final SwitchPreference mSwitch;
+    private final CharSequence mOriginalSummary;
+
+    private WifiManager mWifiManager;
+    private final IntentFilter mIntentFilter;
+
+    ConnectivityManager mCm;
+    private String[] mWifiRegexs;
+
+    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            String action = intent.getAction();
+            Log.i("ROCKCHIP","action = " + action);
+            if (WifiManager.WIFI_AP_STATE_CHANGED_ACTION.equals(action)) {
+                int state = intent.getIntExtra(
+                        WifiManager.EXTRA_WIFI_AP_STATE, WifiManager.WIFI_AP_STATE_FAILED);
+                if (state == WifiManager.WIFI_AP_STATE_FAILED) {
+                    int reason = intent.getIntExtra(WifiManager.EXTRA_WIFI_AP_FAILURE_REASON,
+                            WifiManager.SAP_START_FAILURE_GENERAL);
+                    handleWifiApStateChanged(state, reason);
+                } else {
+                    handleWifiApStateChanged(state, WifiManager.SAP_START_FAILURE_GENERAL);
+                }
+            } else if (ConnectivityManager.ACTION_TETHER_STATE_CHANGED.equals(action)) {
+                ArrayList<String> available = intent.getStringArrayListExtra(
+                        ConnectivityManager.EXTRA_AVAILABLE_TETHER);
+                ArrayList<String> active = intent.getStringArrayListExtra(
+                        ConnectivityManager.EXTRA_ACTIVE_TETHER);
+                ArrayList<String> errored = intent.getStringArrayListExtra(
+                        ConnectivityManager.EXTRA_ERRORED_TETHER);
+                updateTetherState(available.toArray(), active.toArray(), errored.toArray());
+            } else if (Intent.ACTION_AIRPLANE_MODE_CHANGED.equals(action)) {
+                enableWifiSwitch();
+            }
+        }
+    };
+
+    public WifiApEnabler(Context context,
+                         SwitchPreference switchPreference) {
+        mContext = context;
+        mSwitch = switchPreference;
+        mOriginalSummary = switchPreference.getSummary();
+        switchPreference.setPersistent(false);
+
+        mWifiManager = (WifiManager) context.getSystemService(Context.WIFI_SERVICE);
+        mCm = (ConnectivityManager) mContext.getSystemService(Context.CONNECTIVITY_SERVICE);
+
+        mWifiRegexs = mCm.getTetherableWifiRegexs();
+
+        mIntentFilter = new IntentFilter(WifiManager.WIFI_AP_STATE_CHANGED_ACTION);
+        mIntentFilter.addAction(ConnectivityManager.ACTION_TETHER_STATE_CHANGED);
+        mIntentFilter.addAction(Intent.ACTION_AIRPLANE_MODE_CHANGED);
+    }
+
+    public void resume() {
+        mContext.registerReceiver(mReceiver, mIntentFilter);
+        enableWifiSwitch();
+    }
+
+    public void pause() {
+        mContext.unregisterReceiver(mReceiver);
+    }
+
+    private void enableWifiSwitch() {
+        boolean isAirplaneMode = Settings.Global.getInt(mContext.getContentResolver(),
+                Settings.Global.AIRPLANE_MODE_ON, 0) != 0;
+        if (!isAirplaneMode) {
+            mSwitch.setEnabled(true);
+        } else {
+            mSwitch.setSummary(mOriginalSummary);
+            mSwitch.setEnabled(false);
+        }
+    }
+
+    public void updateConfigSummary(WifiConfiguration wifiConfig) {
+        String s = mContext.getString(
+                com.android.internal.R.string.wifi_tether_configure_ssid_default);
+        mSwitch.setSummary(String.format(
+                mContext.getString(R.string.wifi_tether_enabled_subtext),
+                (wifiConfig == null) ? s : wifiConfig.SSID));
+    }
+
+    private void updateTetherState(Object[] available, Object[] tethered, Object[] errored) {
+        boolean wifiTethered = false;
+        boolean wifiErrored = false;
+
+        for (Object o : tethered) {
+            String s = (String) o;
+            for (String regex : mWifiRegexs) {
+                if (s.matches(regex)) wifiTethered = true;
+            }
+        }
+        for (Object o : errored) {
+            String s = (String) o;
+            for (String regex : mWifiRegexs) {
+                if (s.matches(regex)) wifiErrored = true;
+            }
+        }
+
+        if (wifiTethered) {
+            WifiConfiguration wifiConfig = mWifiManager.getWifiApConfiguration();
+            updateConfigSummary(wifiConfig);
+        } else if (wifiErrored) {
+            mSwitch.setSummary(R.string.wifi_error);
+        }
+    }
+
+    private void handleWifiApStateChanged(int state, int reason) {
+        switch (state) {
+            case WifiManager.WIFI_AP_STATE_ENABLING:
+                mSwitch.setSummary(R.string.wifi_tether_starting);
+                mSwitch.setEnabled(false);
+                break;
+            case WifiManager.WIFI_AP_STATE_ENABLED:
+                /**
+                 * Summary on enable is handled by tether
+                 * broadcast notice
+                 */
+                mSwitch.setChecked(true);
+                /* Doesnt need the airplane check */
+                mSwitch.setEnabled(true);
+                break;
+            case WifiManager.WIFI_AP_STATE_DISABLING:
+                mSwitch.setSummary(R.string.wifi_tether_stopping);
+                mSwitch.setChecked(false);
+                mSwitch.setEnabled(false);
+                break;
+            case WifiManager.WIFI_AP_STATE_DISABLED:
+                mSwitch.setChecked(false);
+                mSwitch.setSummary(mOriginalSummary);
+                enableWifiSwitch();
+                break;
+            default:
+                mSwitch.setChecked(false);
+                if (reason == WifiManager.SAP_START_FAILURE_NO_CHANNEL) {
+                    mSwitch.setSummary(R.string.wifi_sap_no_channel_error);
+                } else {
+                    mSwitch.setSummary(R.string.wifi_error);
+                }
+                enableWifiSwitch();
+        }
+    }
+}
diff --git a/Settings/src/com/android/tv/settings/vpn/GearPreference.java b/Settings/src/com/android/tv/settings/vpn/GearPreference.java
new file mode 100755
index 00000000..2db143c9
--- /dev/null
+++ b/Settings/src/com/android/tv/settings/vpn/GearPreference.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License
+ */
+
+package com.android.tv.settings.vpn;
+
+import android.content.Context;
+import android.support.v7.preference.PreferenceViewHolder;
+import android.util.AttributeSet;
+import android.view.View;
+
+import com.android.settingslib.RestrictedPreference;
+import com.android.tv.settings.R;
+
+/**
+ * A preference with a Gear on the side
+ */
+public class GearPreference extends RestrictedPreference implements View.OnClickListener {
+
+    private OnGearClickListener mOnGearClickListener;
+
+    public GearPreference(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        setWidgetLayoutResource(R.layout.preference_widget_settings);
+    }
+
+    public void setOnGearClickListener(OnGearClickListener l) {
+        mOnGearClickListener = l;
+        notifyChanged();
+    }
+
+    @Override
+    public void onBindViewHolder(PreferenceViewHolder holder) {
+        super.onBindViewHolder(holder);
+        final View gear = holder.findViewById(R.id.settings_button);
+        gear.setVisibility(View.GONE);
+        gear.setOnClickListener(this);
+        gear.setEnabled(true);  // Make gear available even if the preference itself is disabled.
+    }
+
+    @Override
+    public void onClick(View v) {
+        if (v.getId() == R.id.settings_button) {
+            if (mOnGearClickListener != null) {
+                mOnGearClickListener.onGearClick(this);
+            }
+        }
+    }
+
+    public interface OnGearClickListener {
+        void onGearClick(GearPreference p);
+    }
+}
diff --git a/Settings/src/com/android/tv/settings/vpn/LegacyVpnPreference.java b/Settings/src/com/android/tv/settings/vpn/LegacyVpnPreference.java
new file mode 100755
index 00000000..0d274a5e
--- /dev/null
+++ b/Settings/src/com/android/tv/settings/vpn/LegacyVpnPreference.java
@@ -0,0 +1,71 @@
+package com.android.tv.settings.vpn;
+
+import android.content.Context;
+import android.support.v7.preference.Preference;
+import android.text.TextUtils;
+import android.view.View;
+
+import com.android.internal.net.VpnProfile;
+import com.android.tv.settings.R;
+
+import static com.android.internal.net.LegacyVpnInfo.STATE_CONNECTED;
+
+/**
+ * {@link android.support.v7.preference.Preference} tracks the underlying legacy vpn profile and
+ * its connection state.
+ */
+public class LegacyVpnPreference extends ManageablePreference {
+    private VpnProfile mProfile;
+
+    public LegacyVpnPreference(Context context) {
+        super(context, null /* attrs */);
+        setIcon(R.drawable.ic_launcher_settings);
+    }
+
+    public VpnProfile getProfile() {
+        return mProfile;
+    }
+
+    public void setProfile(VpnProfile profile) {
+        final String oldLabel = (mProfile != null ? mProfile.name : null);
+        final String newLabel = (profile != null ? profile.name : null);
+        if (!TextUtils.equals(oldLabel, newLabel)) {
+            setTitle(newLabel);
+            notifyHierarchyChanged();
+        }
+        mProfile = profile;
+    }
+
+    @Override
+    public int compareTo(Preference preference) {
+        if (preference instanceof LegacyVpnPreference) {
+            LegacyVpnPreference another = (LegacyVpnPreference) preference;
+            int result;
+            if ((result = another.mState - mState) == 0 &&
+                    (result = mProfile.name.compareToIgnoreCase(another.mProfile.name)) == 0 &&
+                    (result = mProfile.type - another.mProfile.type) == 0) {
+                result = mProfile.key.compareTo(another.mProfile.key);
+            }
+            return result;
+        } /*else if (preference instanceof AppPreference) {
+            // Try to sort connected VPNs first
+            AppPreference another = (AppPreference) preference;
+            if (mState != STATE_CONNECTED && another.getState() == AppPreference.STATE_CONNECTED) {
+                return 1;
+            }
+            // Show configured VPNs before app VPNs
+            return -1;
+        } */ else {
+            return super.compareTo(preference);
+        }
+    }
+
+    @Override
+    public void onClick(View v) {
+        if (v.getId() == R.id.settings_button && isDisabledByAdmin()) {
+            performClick();
+            return;
+        }
+        super.onClick(v);
+    }
+}
diff --git a/Settings/src/com/android/tv/settings/vpn/ManageablePreference.java b/Settings/src/com/android/tv/settings/vpn/ManageablePreference.java
new file mode 100755
index 00000000..4f8ebdff
--- /dev/null
+++ b/Settings/src/com/android/tv/settings/vpn/ManageablePreference.java
@@ -0,0 +1,95 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tv.settings.vpn;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.os.UserHandle;
+import android.os.UserManager;
+import android.text.TextUtils;
+import android.util.AttributeSet;
+
+import com.android.tv.settings.R;
+
+/**
+ * This class sets appropriate enabled state and user admin message when userId is set
+ */
+public abstract class ManageablePreference extends GearPreference {
+
+    public static int STATE_NONE = -1;
+
+    boolean mIsAlwaysOn = false;
+    int mState = STATE_NONE;
+    int mUserId;
+
+    public ManageablePreference(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        setPersistent(false);
+        setOrder(0);
+        setUserId(UserHandle.myUserId());
+    }
+
+    public int getUserId() {
+        return mUserId;
+    }
+
+    public void setUserId(int userId) {
+        mUserId = userId;
+        checkRestrictionAndSetDisabled(UserManager.DISALLOW_CONFIG_VPN, userId);
+    }
+
+    public boolean isAlwaysOn() {
+        return mIsAlwaysOn;
+    }
+
+    public int getState() {
+        return mState;
+    }
+
+    public void setState(int state) {
+        if (mState != state) {
+            mState = state;
+            updateSummary();
+            notifyHierarchyChanged();
+        }
+    }
+
+    public void setAlwaysOn(boolean isEnabled) {
+        if (mIsAlwaysOn != isEnabled) {
+            mIsAlwaysOn = isEnabled;
+            updateSummary();
+        }
+    }
+
+    /**
+     * Update the preference summary string (see {@see Preference#setSummary}) with a string
+     * reflecting connection status and always-on setting.
+     * <p>
+     * State is not shown for {@code STATE_NONE}.
+     */
+    protected void updateSummary() {
+        final Resources res = getContext().getResources();
+        final String[] states = res.getStringArray(R.array.vpn_states);
+        String summary = (mState == STATE_NONE ? "" : states[mState]);
+        if (mIsAlwaysOn) {
+            final String alwaysOnString = res.getString(R.string.vpn_always_on_active);
+            summary = TextUtils.isEmpty(summary) ? alwaysOnString : res.getString(
+                    R.string.join_two_unrelated_items, summary, alwaysOnString);
+        }
+        setSummary(summary);
+    }
+}
diff --git a/Settings/src/com/android/tv/settings/vpn/VpnCreateActivity.java b/Settings/src/com/android/tv/settings/vpn/VpnCreateActivity.java
new file mode 100755
index 00000000..dd727031
--- /dev/null
+++ b/Settings/src/com/android/tv/settings/vpn/VpnCreateActivity.java
@@ -0,0 +1,615 @@
+/**
+ *
+ */
+package com.android.tv.settings.vpn;
+
+import android.content.DialogInterface;
+import android.util.Log;
+import android.view.View;
+import android.widget.CheckBox;
+import android.widget.Spinner;
+import android.widget.TextView;
+import android.os.ServiceManager;
+import android.net.IConnectivityManager;
+
+import com.android.tv.settings.BaseInputActivity;
+
+import android.app.AlertDialog;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.Intent;
+import android.content.res.Configuration;
+import android.net.ConnectivityManager;
+import android.os.Bundle;
+import android.os.RemoteException;
+import android.os.SystemProperties;
+import android.os.UserHandle;
+import android.security.Credentials;
+import android.security.KeyStore;
+import android.text.Editable;
+import android.text.TextWatcher;
+import android.view.View;
+import android.view.WindowManager;
+import android.widget.AdapterView;
+import android.widget.ArrayAdapter;
+import android.widget.Button;
+import android.widget.CheckBox;
+import android.widget.CompoundButton;
+import android.widget.Spinner;
+import android.widget.TextView;
+import android.widget.Toast;
+
+import com.android.internal.net.LegacyVpnInfo;
+import com.android.internal.net.VpnConfig;
+import com.android.internal.net.VpnProfile;
+
+import java.net.InetAddress;
+
+import com.android.tv.settings.R;
+import com.android.tv.settings.data.ConstData;
+
+/**
+ * @author GaoFei
+ *         VPN创建Activity
+ */
+public class VpnCreateActivity extends BaseInputActivity implements TextWatcher,
+        View.OnClickListener, AdapterView.OnItemSelectedListener,
+        CompoundButton.OnCheckedChangeListener {
+    private static final String TAG = "VpnCreateActivity";
+    private final IConnectivityManager mService = IConnectivityManager.Stub.asInterface(
+            ServiceManager.getService(Context.CONNECTIVITY_SERVICE));
+    private final KeyStore mKeyStore = KeyStore.getInstance();
+    private View.OnClickListener mListener;
+    private VpnProfile mProfile;
+
+    private boolean mEditing = true;
+    private boolean mExists;
+
+    private View mView;
+
+    private TextView mName;
+    private Spinner mType;
+    private TextView mServer;
+    private TextView mUsername;
+    private TextView mPassword;
+    private TextView mSearchDomains;
+    private TextView mDnsServers;
+    private TextView mRoutes;
+    private CheckBox mMppe;
+    private TextView mL2tpSecret;
+    private TextView mIpsecIdentifier;
+    private TextView mIpsecSecret;
+    private Spinner mIpsecUserCert;
+    private Spinner mIpsecCaCert;
+    private Spinner mIpsecServerCert;
+    private CheckBox mSaveLogin;
+    private CheckBox mShowOptions;
+    private CheckBox mAlwaysOnVpn;
+    private Button mBtnOK;
+    private Button mBtnCancel;
+    private Button mBtnForget;
+    private Button mBtnEdit;
+
+    @Override
+    public void init() {
+        mView = getContentView();
+        Intent intent = getIntent();
+        mProfile = (VpnProfile) intent.getParcelableExtra(ConstData.IntentKey.VPN_PROFILE);
+        if (mProfile == null)
+            mProfile = new VpnProfile(Long.toHexString(System.currentTimeMillis()));
+        mEditing = intent.getBooleanExtra(ConstData.IntentKey.VPN_EDITING, true);
+        mExists = intent.getBooleanExtra(ConstData.IntentKey.VPN_EXIST, false);
+        Context context = this;
+
+        // First, find out all the fields.
+        mName = (TextView) mView.findViewById(R.id.name);
+        mType = (Spinner) mView.findViewById(R.id.type);
+        mServer = (TextView) mView.findViewById(R.id.server);
+        mUsername = (TextView) mView.findViewById(R.id.username);
+        mPassword = (TextView) mView.findViewById(R.id.password);
+        mSearchDomains = (TextView) mView.findViewById(R.id.search_domains);
+        mDnsServers = (TextView) mView.findViewById(R.id.dns_servers);
+        mRoutes = (TextView) mView.findViewById(R.id.routes);
+        mMppe = (CheckBox) mView.findViewById(R.id.mppe);
+        mL2tpSecret = (TextView) mView.findViewById(R.id.l2tp_secret);
+        mIpsecIdentifier = (TextView) mView.findViewById(R.id.ipsec_identifier);
+        mIpsecSecret = (TextView) mView.findViewById(R.id.ipsec_secret);
+        mIpsecUserCert = (Spinner) mView.findViewById(R.id.ipsec_user_cert);
+        mIpsecCaCert = (Spinner) mView.findViewById(R.id.ipsec_ca_cert);
+        mIpsecServerCert = (Spinner) mView.findViewById(R.id.ipsec_server_cert);
+        mSaveLogin = (CheckBox) mView.findViewById(R.id.save_login);
+        mShowOptions = (CheckBox) mView.findViewById(R.id.show_options);
+        mAlwaysOnVpn = (CheckBox) mView.findViewById(R.id.always_on_vpn);
+        mBtnOK = (Button) mView.findViewById(R.id.btn_ok);
+        mBtnCancel = (Button) mView.findViewById(R.id.btn_cancel);
+        mBtnForget = (Button) mView.findViewById(R.id.btn_forget);
+        mBtnEdit = (Button) mView.findViewById(R.id.btn_edit);
+        // Second, copy values from the profile.
+        mName.setText(mProfile.name);
+        mType.setSelection(mProfile.type);
+        mServer.setText(mProfile.server);
+        if (mProfile.saveLogin) {
+            mUsername.setText(mProfile.username);
+            mPassword.setText(mProfile.password);
+        }
+        mSearchDomains.setText(mProfile.searchDomains);
+        mDnsServers.setText(mProfile.dnsServers);
+        mRoutes.setText(mProfile.routes);
+        mMppe.setChecked(mProfile.mppe);
+        mL2tpSecret.setText(mProfile.l2tpSecret);
+        mIpsecIdentifier.setText(mProfile.ipsecIdentifier);
+        mIpsecSecret.setText(mProfile.ipsecSecret);
+        loadCertificates(mIpsecUserCert, Credentials.USER_PRIVATE_KEY, 0, mProfile.ipsecUserCert);
+        loadCertificates(mIpsecCaCert, Credentials.CA_CERTIFICATE,
+                R.string.vpn_no_ca_cert, mProfile.ipsecCaCert);
+        loadCertificates(mIpsecServerCert, Credentials.USER_CERTIFICATE,
+                R.string.vpn_no_server_cert, mProfile.ipsecServerCert);
+        mSaveLogin.setChecked(mProfile.saveLogin);
+        mAlwaysOnVpn.setChecked(mProfile.key.equals(VpnUtils.getLockdownVpn()));
+        mAlwaysOnVpn.setOnCheckedChangeListener(this);
+        // Update SaveLogin checkbox after Always-on checkbox is updated
+        updateSaveLoginStatus();
+
+        // Hide lockdown VPN on devices that require IMS authentication
+        if (SystemProperties.getBoolean("persist.radio.imsregrequired", false)) {
+            mAlwaysOnVpn.setVisibility(View.GONE);
+        }
+
+        // Third, add listeners to required fields.
+        mName.addTextChangedListener(this);
+        mType.setOnItemSelectedListener(this);
+        mServer.addTextChangedListener(this);
+        mUsername.addTextChangedListener(this);
+        mPassword.addTextChangedListener(this);
+        mDnsServers.addTextChangedListener(this);
+        mRoutes.addTextChangedListener(this);
+        mIpsecSecret.addTextChangedListener(this);
+        mIpsecUserCert.setOnItemSelectedListener(this);
+        mShowOptions.setOnClickListener(this);
+
+        // Fourth, determine whether to do editing or connecting.
+        boolean valid = validate(true);
+        mEditing = mEditing || !valid;
+
+        if (mEditing) {
+            setInputTitle(getString(R.string.vpn_edit));
+
+            // Show common fields.
+            mView.findViewById(R.id.editor).setVisibility(View.VISIBLE);
+
+            // Show type-specific fields.
+            changeType(mProfile.type);
+
+            // Hide 'save login' when we are editing.
+            mSaveLogin.setVisibility(View.GONE);
+
+            // Switch to advanced view immediately if any advanced options are on
+            if (!mProfile.searchDomains.isEmpty() || !mProfile.dnsServers.isEmpty() ||
+                    !mProfile.routes.isEmpty()) {
+                showAdvancedOptions();
+            }
+
+            // Create a button to forget the profile if it has already been saved..
+            if (mExists) {
+                mBtnForget.setVisibility(View.VISIBLE);
+                setButton(mBtnForget, this);
+               /* setButton(DialogInterface.BUTTON_NEUTRAL,
+                        context.getString(R.string.vpn_forget), mListener);*/
+            }
+
+            // Create a button to save the profile.
+            setButton(mBtnOK, this);
+           /* setButton(DialogInterface.BUTTON_POSITIVE,
+                    context.getString(R.string.vpn_save), mListener);*/
+        } else {
+            setInputTitle(context.getString(R.string.vpn_connect_to, mProfile.name));
+            mBtnEdit.setVisibility(View.VISIBLE);
+            mBtnEdit.setOnClickListener(this);
+            // Create a button to connect the network.
+            /*setButton(DialogInterface.BUTTON_POSITIVE,
+                    context.getString(R.string.vpn_connect), mListener);*/
+            setButton(mBtnOK, this);
+            mBtnOK.setText(getString(R.string.vpn_connect));
+        }
+
+        // Always provide a cancel button.
+        mBtnCancel.setText(context.getString(R.string.vpn_cancel));
+        setButton(mBtnCancel, this);
+        // Let AlertDialog create everything.
+
+        // Disable the action button if necessary.
+        /*getButton(DialogInterface.BUTTON_POSITIVE)
+                .setEnabled(mEditing ? valid : validate(false));*/
+        mBtnOK.setEnabled(mEditing ? valid : validate(false));
+        // Workaround to resize the dialog for the input method.
+       /* getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE |
+                WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE);*/
+        updateFocus();
+    }
+
+
+    @Override
+    public int getContentLayoutRes() {
+        return R.layout.content_vpn_create;
+    }
+
+
+    @Override
+    public String getInputTitle() {
+        return getString(R.string.create_vpn);
+    }
+
+
+    @Override
+    public void afterTextChanged(Editable field) {
+        mBtnOK.setEnabled(validate(mEditing));
+    }
+
+    @Override
+    public void beforeTextChanged(CharSequence s, int start, int count, int after) {
+    }
+
+    @Override
+    public void onTextChanged(CharSequence s, int start, int before, int count) {
+    }
+
+    @Override
+    public void onClick(View view) {
+        if (view == mShowOptions) {
+            showAdvancedOptions();
+            updateFocus();
+        }
+        VpnProfile profile = getProfile();
+        if (view == mBtnOK) {
+            // Update KeyStore entry
+            KeyStore.getInstance().put(Credentials.VPN + profile.key, profile.encode(),
+                    KeyStore.UID_SELF, /* flags */ 0);
+
+            // Flush out old version of profile
+            disconnect(profile);
+
+            updateLockdownVpn(isVpnAlwaysOn(), profile);
+
+            // If we are not editing, connect!
+            if (!isEditing() && !VpnUtils.isVpnLockdown(profile.key)) {
+                try {
+                    connect(profile);
+                } catch (RemoteException e) {
+                    Log.e(TAG, "Failed to connect", e);
+                }
+            }
+            finish();
+        } else if (view == mBtnForget) {
+            // Disable profile if connected
+            disconnect(profile);
+
+            // Delete from KeyStore
+            KeyStore keyStore = KeyStore.getInstance();
+            keyStore.delete(Credentials.VPN + profile.key, KeyStore.UID_SELF);
+
+            updateLockdownVpn(false, profile);
+            finish();
+        } else if (view == mBtnCancel) {
+            finish();
+        } else if (view == mBtnEdit) {
+            Intent editIntent = new Intent(this, VpnCreateActivity.class);
+            editIntent.putExtra(ConstData.IntentKey.VPN_PROFILE, mProfile);
+            editIntent.putExtra(ConstData.IntentKey.VPN_EXIST, true);
+            editIntent.putExtra(ConstData.IntentKey.VPN_EDITING, true);
+            startActivity(editIntent);
+            finish();
+        }
+
+    }
+
+    @Override
+    public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
+        if (parent == mType) {
+            changeType(position);
+        }
+        mBtnOK.setEnabled(validate(mEditing));
+    }
+
+    @Override
+    public void onNothingSelected(AdapterView<?> parent) {
+    }
+
+    @Override
+    public void onCheckedChanged(CompoundButton compoundButton, boolean b) {
+        if (compoundButton == mAlwaysOnVpn) {
+            updateSaveLoginStatus();
+            mBtnOK.setEnabled(validate(mEditing));
+        }
+    }
+
+    public boolean isVpnAlwaysOn() {
+        return mAlwaysOnVpn.isChecked();
+    }
+
+    private void updateSaveLoginStatus() {
+        if (mAlwaysOnVpn.isChecked()) {
+            mSaveLogin.setChecked(true);
+            mSaveLogin.setEnabled(false);
+        } else {
+            mSaveLogin.setChecked(mProfile.saveLogin);
+            mSaveLogin.setEnabled(true);
+        }
+    }
+
+    private void showAdvancedOptions() {
+        mView.findViewById(R.id.options).setVisibility(View.VISIBLE);
+        mShowOptions.setVisibility(View.GONE);
+    }
+
+    private void changeType(int type) {
+        // First, hide everything.
+        mMppe.setVisibility(View.GONE);
+        mView.findViewById(R.id.l2tp).setVisibility(View.GONE);
+        mView.findViewById(R.id.ipsec_psk).setVisibility(View.GONE);
+        mView.findViewById(R.id.ipsec_user).setVisibility(View.GONE);
+        mView.findViewById(R.id.ipsec_peer).setVisibility(View.GONE);
+
+        // Then, unhide type-specific fields.
+        switch (type) {
+            case VpnProfile.TYPE_PPTP:
+                mMppe.setVisibility(View.VISIBLE);
+                break;
+
+            case VpnProfile.TYPE_L2TP_IPSEC_PSK:
+                mView.findViewById(R.id.l2tp).setVisibility(View.VISIBLE);
+                // fall through
+            case VpnProfile.TYPE_IPSEC_XAUTH_PSK:
+                mView.findViewById(R.id.ipsec_psk).setVisibility(View.VISIBLE);
+                break;
+
+            case VpnProfile.TYPE_L2TP_IPSEC_RSA:
+                mView.findViewById(R.id.l2tp).setVisibility(View.VISIBLE);
+                // fall through
+            case VpnProfile.TYPE_IPSEC_XAUTH_RSA:
+                mView.findViewById(R.id.ipsec_user).setVisibility(View.VISIBLE);
+                // fall through
+            case VpnProfile.TYPE_IPSEC_HYBRID_RSA:
+                mView.findViewById(R.id.ipsec_peer).setVisibility(View.VISIBLE);
+                break;
+        }
+        updateFocus();
+    }
+
+    private boolean validate(boolean editing) {
+        if (mAlwaysOnVpn.isChecked() && !getProfile().isValidLockdownProfile()) {
+            return false;
+        }
+        if (!editing) {
+            return mUsername.getText().length() != 0 && mPassword.getText().length() != 0;
+        }
+        if (mName.getText().length() == 0 || mServer.getText().length() == 0 ||
+                !validateAddresses(mDnsServers.getText().toString(), false) ||
+                !validateAddresses(mRoutes.getText().toString(), true)) {
+            return false;
+        }
+        switch (mType.getSelectedItemPosition()) {
+            case VpnProfile.TYPE_PPTP:
+            case VpnProfile.TYPE_IPSEC_HYBRID_RSA:
+                return true;
+
+            case VpnProfile.TYPE_L2TP_IPSEC_PSK:
+            case VpnProfile.TYPE_IPSEC_XAUTH_PSK:
+                return mIpsecSecret.getText().length() != 0;
+
+            case VpnProfile.TYPE_L2TP_IPSEC_RSA:
+            case VpnProfile.TYPE_IPSEC_XAUTH_RSA:
+                return mIpsecUserCert.getSelectedItemPosition() != 0;
+        }
+        return false;
+    }
+
+    private boolean validateAddresses(String addresses, boolean cidr) {
+        try {
+            for (String address : addresses.split(" ")) {
+                if (address.isEmpty()) {
+                    continue;
+                }
+                // Legacy VPN currently only supports IPv4.
+                int prefixLength = 32;
+                if (cidr) {
+                    String[] parts = address.split("/", 2);
+                    address = parts[0];
+                    prefixLength = Integer.parseInt(parts[1]);
+                }
+                byte[] bytes = InetAddress.parseNumericAddress(address).getAddress();
+                int integer = (bytes[3] & 0xFF) | (bytes[2] & 0xFF) << 8 |
+                        (bytes[1] & 0xFF) << 16 | (bytes[0] & 0xFF) << 24;
+                if (bytes.length != 4 || prefixLength < 0 || prefixLength > 32 ||
+                        (prefixLength < 32 && (integer << prefixLength) != 0)) {
+                    return false;
+                }
+            }
+        } catch (Exception e) {
+            return false;
+        }
+        return true;
+    }
+
+    private void loadCertificates(Spinner spinner, String prefix, int firstId, String selected) {
+        Context context = this;
+        String first = (firstId == 0) ? "" : context.getString(firstId);
+        String[] certificates = mKeyStore.list(prefix);
+
+        if (certificates == null || certificates.length == 0) {
+            certificates = new String[]{first};
+        } else {
+            String[] array = new String[certificates.length + 1];
+            array[0] = first;
+            System.arraycopy(certificates, 0, array, 1, certificates.length);
+            certificates = array;
+        }
+
+        ArrayAdapter<String> adapter = new ArrayAdapter<String>(
+                context, android.R.layout.simple_spinner_item, certificates);
+        adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
+        spinner.setAdapter(adapter);
+
+        for (int i = 1; i < certificates.length; ++i) {
+            if (certificates[i].equals(selected)) {
+                spinner.setSelection(i);
+                break;
+            }
+        }
+    }
+
+    boolean isEditing() {
+        return mEditing;
+    }
+
+    VpnProfile getProfile() {
+        // First, save common fields.
+        VpnProfile profile = new VpnProfile(mProfile.key);
+        profile.name = mName.getText().toString();
+        profile.type = mType.getSelectedItemPosition();
+        profile.server = mServer.getText().toString().trim();
+        profile.username = mUsername.getText().toString();
+        profile.password = mPassword.getText().toString();
+        profile.searchDomains = mSearchDomains.getText().toString().trim();
+        profile.dnsServers = mDnsServers.getText().toString().trim();
+        profile.routes = mRoutes.getText().toString().trim();
+
+        // Then, save type-specific fields.
+        switch (profile.type) {
+            case VpnProfile.TYPE_PPTP:
+                profile.mppe = mMppe.isChecked();
+                break;
+
+            case VpnProfile.TYPE_L2TP_IPSEC_PSK:
+                profile.l2tpSecret = mL2tpSecret.getText().toString();
+                // fall through
+            case VpnProfile.TYPE_IPSEC_XAUTH_PSK:
+                profile.ipsecIdentifier = mIpsecIdentifier.getText().toString();
+                profile.ipsecSecret = mIpsecSecret.getText().toString();
+                break;
+
+            case VpnProfile.TYPE_L2TP_IPSEC_RSA:
+                profile.l2tpSecret = mL2tpSecret.getText().toString();
+                // fall through
+            case VpnProfile.TYPE_IPSEC_XAUTH_RSA:
+                if (mIpsecUserCert.getSelectedItemPosition() != 0) {
+                    profile.ipsecUserCert = (String) mIpsecUserCert.getSelectedItem();
+                }
+                // fall through
+            case VpnProfile.TYPE_IPSEC_HYBRID_RSA:
+                if (mIpsecCaCert.getSelectedItemPosition() != 0) {
+                    profile.ipsecCaCert = (String) mIpsecCaCert.getSelectedItem();
+                }
+                if (mIpsecServerCert.getSelectedItemPosition() != 0) {
+                    profile.ipsecServerCert = (String) mIpsecServerCert.getSelectedItem();
+                }
+                break;
+        }
+
+        final boolean hasLogin = !profile.username.isEmpty() || !profile.password.isEmpty();
+        profile.saveLogin = mSaveLogin.isChecked() || (mEditing && hasLogin);
+        return profile;
+    }
+
+
+    private void setButton(Button button, View.OnClickListener onClickListener) {
+        //button.setText(text);
+        button.setOnClickListener(onClickListener);
+    }
+
+    private void updateLockdownVpn(boolean isVpnAlwaysOn, VpnProfile profile) {
+        // Save lockdown vpn
+        if (isVpnAlwaysOn) {
+            // Show toast if vpn profile is not valid
+            if (!profile.isValidLockdownProfile()) {
+                Toast.makeText(this, R.string.vpn_lockdown_config_error,
+                        Toast.LENGTH_LONG).show();
+                return;
+            }
+
+            final ConnectivityManager conn = ConnectivityManager.from(this);
+            conn.setAlwaysOnVpnPackageForUser(UserHandle.myUserId(), null,
+                    /* lockdownEnabled */ false);
+            VpnUtils.setLockdownVpn(this, profile.key);
+        } else {
+            // update only if lockdown vpn has been changed
+            if (VpnUtils.isVpnLockdown(profile.key)) {
+                VpnUtils.clearLockdownVpn(this);
+            }
+        }
+    }
+
+    private void disconnect(VpnProfile profile) {
+        try {
+            LegacyVpnInfo connected = mService.getLegacyVpnInfo(UserHandle.myUserId());
+            if (connected != null && profile.key.equals(connected.key)) {
+                VpnUtils.clearLockdownVpn(this);
+                mService.prepareVpn(VpnConfig.LEGACY_VPN, VpnConfig.LEGACY_VPN,
+                        UserHandle.myUserId());
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "Failed to disconnect", e);
+        }
+    }
+
+    private void connect(VpnProfile profile) throws RemoteException {
+        try {
+            mService.startLegacyVpn(profile);
+        } catch (IllegalStateException e) {
+            Toast.makeText(this, R.string.vpn_no_network, Toast.LENGTH_LONG).show();
+        }
+    }
+
+    @Override
+    public void onConfigurationChanged(Configuration newConfig) {
+        super.onConfigurationChanged(newConfig);
+    }
+
+    private void updateFocus() {
+        if (!mEditing) {
+            mPassword.setNextFocusDownId(R.id.save_login);
+            mAlwaysOnVpn.setNextFocusDownId(R.id.btn_ok);
+        } else if (!mExists) {
+            mName.setNextFocusDownId(R.id.type);
+            mType.setNextFocusDownId(mServer.getId());
+            mPassword.setNextFocusDownId(R.id.always_on_vpn);
+            mAlwaysOnVpn.setNextFocusDownId(R.id.btn_ok);
+            switch (mType.getSelectedItemPosition()) {
+                case 0:
+                    mServer.setNextFocusDownId(mMppe.getId());
+                    mAlwaysOnVpn.setNextFocusDownId(mBtnOK.getId());
+                    break;
+                case 1:
+                case 2:
+                    mServer.setNextFocusDownId(mL2tpSecret.getId());
+                    if (mShowOptions.getVisibility() == View.VISIBLE)
+                        mIpsecSecret.setNextFocusDownId(mShowOptions.getId());
+                    else
+                        mIpsecSecret.setNextFocusDownId(mSearchDomains.getId());
+                    break;
+                case 3:
+                    mServer.setNextFocusDownId(mIpsecIdentifier.getId());
+                    if (mShowOptions.getVisibility() == View.VISIBLE)
+                        mIpsecSecret.setNextFocusDownId(mShowOptions.getId());
+                    else
+                        mIpsecSecret.setNextFocusDownId(mSearchDomains.getId());
+                    break;
+                case 4:
+                    mServer.setNextFocusDownId(mIpsecUserCert.getId());
+                    if (mShowOptions.getVisibility() == View.VISIBLE)
+                        mIpsecServerCert.setNextFocusDownId(mShowOptions.getId());
+                    else
+                        mIpsecServerCert.setNextFocusDownId(mSearchDomains.getId());
+                    break;
+                case 5:
+                    mServer.setNextFocusDownId(mIpsecCaCert.getId());
+                    if (mShowOptions.getVisibility() == View.VISIBLE)
+                        mIpsecServerCert.setNextFocusDownId(mShowOptions.getId());
+                    else
+                        mIpsecServerCert.setNextFocusDownId(mSearchDomains.getId());
+                    break;
+                default:
+                    break;
+            }
+        }
+    }
+}
diff --git a/Settings/src/com/android/tv/settings/vpn/VpnUtils.java b/Settings/src/com/android/tv/settings/vpn/VpnUtils.java
new file mode 100755
index 00000000..e755516a
--- /dev/null
+++ b/Settings/src/com/android/tv/settings/vpn/VpnUtils.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tv.settings.vpn;
+
+import android.content.Context;
+import android.net.ConnectivityManager;
+import android.security.Credentials;
+import android.security.KeyStore;
+
+/**
+ * Utility functions for vpn.
+ * <p>
+ * Keystore methods should only be called in system user
+ */
+public class VpnUtils {
+
+    public static String getLockdownVpn() {
+        final byte[] value = KeyStore.getInstance().get(Credentials.LOCKDOWN_VPN);
+        return value == null ? null : new String(value);
+    }
+
+    public static void clearLockdownVpn(Context context) {
+        KeyStore.getInstance().delete(Credentials.LOCKDOWN_VPN);
+        // Always notify ConnectivityManager after keystore update
+        context.getSystemService(ConnectivityManager.class).updateLockdownVpn();
+    }
+
+    public static void setLockdownVpn(Context context, String lockdownKey) {
+        KeyStore.getInstance().put(Credentials.LOCKDOWN_VPN, lockdownKey.getBytes(),
+                KeyStore.UID_SELF, /* flags */ 0);
+        // Always notify ConnectivityManager after keystore update
+        context.getSystemService(ConnectivityManager.class).updateLockdownVpn();
+    }
+
+    public static boolean isVpnLockdown(String key) {
+        return key.equals(getLockdownVpn());
+    }
+}
\ No newline at end of file
-- 
2.17.1

